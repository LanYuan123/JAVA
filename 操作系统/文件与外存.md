# 文件

![文件系统的层次结构](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png)

-----

## 文件的逻辑结构--文件内部如何组织

所谓的逻辑结构，就是指在用户看来，文件内部的数据应该是如何组织起来的

文件的逻辑结构：
- 无结构文件
- 有结构文件
  - 顺序文件
  - 索引文件
  - 索引顺序文件
  
### 无结构文件

无结构文件：文件内部的数据就是一系列二进制流或字符流组成。又被称为“**流式文件**”

### 有结构文件

有结构文件：由一组相似的记录组成，又称“记录式文件”。每条记录由若干项数据项组成，如数据库表文件。一般来说每条记录有一个数据项可作为关键字（作为识别不同记录的ID）。根据记录的长度又可分为**定长记录**和**可变长记录**

#### 顺序文件

顺序文件：在逻辑上文件中的记录一个接一个地顺序排列，记录可以上**定长**的或者**可变长**的。各个记录在物理上可以**顺序存储**或者**链式存储**

顺序文件又可以分为**串结构**和**顺序结构**。

串结构：记录之间的顺序和关键字无关

顺序结构：记录之间的顺序按照关键字顺序排列

![顺序文件](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6.png)

#### 索引文件

在顺序文件中，可变长记录是无法实现随机访问的，我们使用索引文件可以解决这个问题。

可以为文件本身建立一张索引表，索引表的每个表项记录了每条记录的长度和指向指向记录存放地址的指针，还有索引表本身是定长记录的顺序文件，因此可以快速找到第i个记录对应的索引项。索引表还可以将关键字作为索引号内容，若按照关键字顺序排列则还可以支持按照关键字折半查找。

每当要增加/删除一条记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合

#### 索引顺序文件

在索引文件中，每个记录对应一个索引表项，因此索引表可能会很大。可以使用索引顺序文件来解决这个问题

索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会文件建立一张索引表，但不同的是：并**不是每个记录对应一个索引项**，而是**一组记录对应一个索引表项**。

在索引顺序文件中，我们先将文件的记录进行分组，再为每个分组建立一张索引表，为了**进一步提高检索效率**，可以为顺序文件**建立多级索引表**，即将顺序文件进行多次分组，为每次分组建立索引文件

-----

## 文件的目录结构--文件之间如何组织

### 文件控制块

操作系统为了更好的组织文件，使用文件目录来管理文件，文件目录其实就是一个文件表，**文件表中的每一条记录被称为文件控制块（FCB）**，**一个文件控制块对应着一个文件或者目录的信息**，FCB的有序集合就被称为“文件目录”

### 索引节点（文件控制块的优化）

其实在查找各级目录的过程中只需要用到“文件名”这个信息，只有文件名匹配时，才需要读出文件的其他信息。因此可以考虑让目录“瘦身”来提升效率。即现在一个FCB只包括两项：**文件名**和**索引节点指针**，将FCB的**其他信息存放到索引节点中**。

当找到文件名对应的目录项时，才需要将索引节点调入到内存中，索引节点记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。存放在**外存**中的索引节点称为“**磁盘索引节点**”，当索引节点放入**内存**后被称为“**内存索引节点**”，相比之下内存节点中的信息更多。

![索引节点](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9.png)

### 目录结构

#### 单击目录结构

早期的操作系统并不支持多级目录，因此整个系统之中只建立一张目录表，每个文件占一个目录项

![单级目录](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%8D%95%E7%BA%A7%E7%9B%AE%E5%BD%95.png)

单级目录实现了“按名存取”，但是**不允许文件重名**。在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中。

#### 两级目录结构

显然，以上的**单级目录**结构**不适用于多用户操作系统**

早期的多用户操作系统，采用两级目录结构。分为**主文件目录**和**用户文件目录**。主文件目录记录用户名及相应用户文件目录的存放位置；用户文件目录由该用户的文件FCB组成。两级目录结构允许用户的文件重名，也可以在目录上实现访问限制（检车此时登陆的用户名是否匹配）

![两级目录结构](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E4%B8%A4%E7%BA%A7%E7%9B%AE%E5%BD%95.png)

#### 树形目录结构

以上的两级目录结构缺乏灵活性，用户不能对自己的文件进行分类，所以我们发明了树形目录结构

树形目录结构是一种很常用的树形目录结构，每一个目录下面可以更低一级的目录，也可以有一些普通的文件

![树形目录结构 ](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95.png)

#### 无环图目录结构

**树形目录结构**虽然可以很方便的对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护，但是，树形结构**不便于实现文件的共享**。为此我们提出了**无环图目录结构**

可以用不同的文件名指向同一个文件，甚至可以指向同一个目录（共享同一个目录下的所有内容）。我们需要为每个共享点设置一个共享计数器，用于记录此时有多少个地方在共享该节点，用户提出删除节点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除节点，只有共享计数器减为0时，才会删除节点

![无环图目录结构](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png)

-----

## 文件的物理结构--文件如何存储

类似于内存分页，磁盘中的存储单元也会被分为一个个“块/磁盘块/物理块”。在很多操作系统中，**磁盘块的大小和内存块、页面的大小相同**。由此内存与磁盘之间的数据交换都是以“块”为单位进行的。

类似于内存管理中，进程的逻辑地址空间被分为一个一个页面。同样的，在外存管理中，为了方便对文件数据进行管理，**文件的逻辑地址空间也被分为了一个一个的文件块**，于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式

![文件分配](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D.png)

### 连续分配

**连续分配**方式要求**每个文件在磁盘上占有一组连续的块**

逻辑地址->物理地址的转换：只需要通过逻辑地址算出**逻辑块号**和**块内偏移量**。用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项，**从FCB获取到起始块号和分配的磁盘块的长度**，物理块号=起始块号+逻辑块号，再加上块内偏移量就得到了实际的物理地址

![连续分配](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D.png)
![连续分配FCB](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8DFCB.png)

优点：
- 支持**顺序访问**和**随机访问**
- 连续分配的文件在**顺序访问的时候速度最快**

缺点：
- 在读取某个磁盘时，需要移动磁头，访问的两个磁盘块相隔越远，移动磁头所需时间就越长。所以，就连续分配而言：**连续分配的文件在顺序读/写时速度最快**
- 因为连续分配所分配的磁盘块是连续的，所以当文件要扩展但是周围又没有空闲块时，需要将文件全部迁移。结论：**连续分配不方便拓展**
- 采用连续分配，有些小空间无法被利用，**存储空间利用率低，会产生难以利用的磁盘碎片**，可以使用**紧凑**技术来处理碎片，但是需要耗费很大的时间代价

### 链接分配--隐式链接

**链式分配**采用**离散分配**的方式，可以为文件离散的分配磁盘块，这是其中的一种**隐式链接**

当用户要访问文件的时候，首先会在目录表中找到对应FCB，**FCB**中记录文件在磁盘中的**起始块号**和**结束块号**，从FCB中年找到起始块号后，将起始块号读入内存，而该盘块中有保存了下一盘块的指针，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑块，以此类推，可以读出后面所有的内容。

![隐式链接](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E9%9A%90%E5%BC%8F%E9%93%BE%E6%8E%A5.png)

优点：
- 隐式链接很**方便文件拓展**
- 所有的空闲磁盘块的都可以被利用，**不会有碎片的问题，外存利用率高**。

缺点：
- 隐式链接只**支持顺序访问**，**不支持随机访问**，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间

### 链式分配--显式链接

**链式分配**采用**离散分配**的方式，可以为文件离散的分配磁盘块，这是其中的一种**显示链接**

显式链接相较于隐式链接，把用于链接文件各物理块的指针显式的存放在一张表中，即**文件分配表（FAT）**中，在**FCB**中只需要记录文件的**起始块号**即可，FAT表中存放了每一个磁盘块的下一块是什么。

在查找某一个逻辑块时，从FCB中找到起始块号，根据起始块号在内存中查询FAT，往后找到i号逻辑块对应的物理块号。逻辑块号转换成物理块号的过程不需要读磁盘操作

![FAT表](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/FAT.png)

注意：**一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存。**FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的

优点：
- 采用显示链接方式的文件，**支持顺序访问**，**也支持随机访问**，由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，**访问速度快很多**
- **不会产生外部碎片**
- 可以很**方便地对文件进行拓展**

缺点：
- FAT表需要占用一定的存储空间

### 索引分配

索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块。索引表存放的磁盘块称为索引块，文件数据存放的磁盘块称为数据块。在FCB中存放了索引块是几号磁盘块。

逻辑地址->物理地址转换：用户给出需要查找逻辑块号i，操作系统找到该文件对应的FCB，**通过FCB可知索引表存放位置**，将索引表从外存读入内存，并查找索引表即可知道i号逻辑块在外存中的位置。

![索引分配](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D.png)

优点：
- 索引分配方式可以支持随机访问
- 文件拓展也很容易实现（只需要给文件分配一个空闲块，并且增加一个索引表项节课）

缺点：
- 索引表需要占用一定空间

可是当一个文件的索引表大小超过了一个磁盘块，我们怎么办呢？我们有三种解决方式：
- 链接方案
- 多层索引
- 混合索引

#### 链接方案

链接方案：**如果索引表太大，一个索引装不下，那么可以将多个索引块如先前的隐式链接一般链接起来存放**。每个索引块会分配一定的空间存储下一个索引块的指针。

缺点：若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到i号索引块，必须依次读入0~i-1号索引块，这就导致**I/O次数过多**，**查找效率很低**

![链接方案](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E9%93%BE%E6%8E%A5%E6%96%B9%E6%A1%88.png)

#### 多层索引

显然上面的链接方案是十分低效的，所以人们又提出了多层索引

多层索引：建立多层索引（**原理类似于多级页面**）。是第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。

缺点：**即使是小文件，访问一个数据块依然需要K+1次读磁盘**

![多层索引](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%A4%9A%E5%B1%82%E7%B4%A2%E5%BC%95.png)

#### 混合索引

混合索引：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含**直接抵制索引**（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级简介索引（指向两层索引表）。

![混合索引](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%B7%B7%E5%90%88%E7%B4%A2%E5%BC%95.png)

-----

## 操作系统提供的关于文件的系统调用

### 创建文件（create系统调用）

进行create系统调用时，需要提供的几个主要参数：
1. 所需外存空间的大小
2. 文件存放路径
3. 文件名

操作系统在处理Create系统调用时，主要做了两件事：
1. **在外存中找到文件所需的空间**
2. 根据文件存放路径的信息找到该目录对应的目录文件，在目录中创建该文件的FCB。FCB包含了文件名、文件在外存中的存放位置等等

### 删除文件（delete系统调用）

进行Delete系统调用时，需要提供的几个主要参数：
1. 文件存放路径
2. 文件名

操作系统在处理Delete系统调用时，主要做了几件事：
1. 根据文件存放路径找到对应的目录文件，从目录文件中找到对应的FCB。
2. 根据FCB记录的文件外存存放文职、文件大小等信息，回收文件占用的磁盘块
3. 从目录表中删除文件对应的目录项

### 打开文件（open系统调用）

很多操作系统中，对文件进行操作之前，要求对文件先使用Open系统调用打开文件，进行Open系统调用时，需要提供的几个主要参数：
1. 文件存放路径
2. 文件名
3. 要对文件进行的操作类型

操作系统在处理系统调用时，主要做了几件事：
1. 根据文件存放路径找到对应的目录文件，从目录文件中找到对应的FCB。并且检查用户是否有操作权限
2. 将目录项复制到内存中的打开文件表中，并将对应表目的编号返回给用户，之后用户使用打开文件表的编号指明要操作的文件

![打开文件](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6.png)

系统有两种打开文件表：属于某个进程的打开文件表和系统的打开文件表。系统的打开文件表其实是方便我们实现文件管理的功能。比如：我们要删除某个txt文件，但是如果此时该文件已被某个“记事本”进程打开，则系统会提示我们暂时无法删除该文件。其实系统在背后就是先检查了系统打开文件表。确认此事是否有进程正在使用该文件

![两种打开文件表](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E4%B8%A4%E7%A7%8D%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E8%A1%A8.png)

### 关闭文件（close系统调用）

操作系统在处理Close系统调用时，主要做了几件事：
1. 将进程的打开文件表相应表项删除
2. 回收分配给该文件的内存空间等资源
3. 系统打开文件表的打开计数器count减1，若count=0，则删除对应表项


### 读文件（read系统调用）

进行Read系统调用时，需要指明是哪个文件（在支持打开文件操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明要读入多少数据、指明读入的数据要放在内存中的什么位置

操作系统在处理Read系统调用时，从读指针指向的外存区域中，将用户指定大小的数据读入用户指定的内存区域中

### 写文件（write系统调用）

进行系统调用时，需要指明是哪个文件（在支持打开文件操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明要写多少数据、写回外存的数据放在内存中什么位置

操作系统在处理系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存
 
-----

## 文件共享

操作系统为用户提供文件共享功能，可以让多个用户共享地使用同一个文件，文件共享的方式有两种，**基于索引节点共享的硬链接**和**基于符号链共享的软链接**。

### 基于索引节点的共享

我们可以在索引节点中设置一个链接计数变量count，用于表示链接到本索引节点上的用户目录项数。若count2，说明此时有两个用户目录项链接到该索引节点上，或者说有两个用户在共享此文件。若某个用户决定“删除”该文件，则只是吧用户目录中与该文件对应的目录项删除，且索引节点的count值减1。若count>0，说明还有用户在使用该文件，不能见文件数据删除，否则指针会悬空，当count=0时才删除文件数据

![索引节点共享](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E5%85%B1%E4%BA%AB.png)

### 基于符号链的共享

索引节点指向的会是一个Link类型的文件，该文件记录了共享文件存放的地址，操作系统会根据该地址找到共享文件，从而实现共享。类似于Windows的快捷方式。

如果共享文件被删除了，则Link文件指向的地址就会找不到该文件

![符号链共享](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%AC%A6%E5%8F%B7%E9%93%BE%E5%85%B1%E4%BA%AB.png)

-----

## 文件保护

### 口令保护

为文件设置一个“口令”，用户请求访问该文件时必须提供“口令”

口令一般存放在文件对应的FCB或索引节点中。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确，则允许该用户访问文件

优点：保存口令的空间开销不多，验证口令的时间开销也很小

缺点：正确的“口令”存放在系统内部，不够安全，如果系统被攻破，则口令也会泄露

### 加密保护

使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密

“密码”和“口令”不同，口令对文件本身没有影响，而密码对文件本身的原始数据进行加密。

优点：保密性强，不需要在系统中存储“密码”

缺点:编码/译码，或者说加密/解密要花费一定时间

### 访问控制

在每个文件的FCB（或者索引节点）中增加一个访问控制列表，该表中记录了各个用户可以对该文件执行哪些操作。

![访问控制](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8.png)

有的计算机可能会有很多个用户，因此访问控制列表可能会很大，可以用精简的访问列表解决。

精简的访问列表：以“组”为单位，标记个“组”用户可以对文件执行哪些操作。当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限。

![精简的访问控制](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%B2%BE%E7%AE%80%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8.png)

-----

# 外存

-----

## 外存空闲块管理

我们在安装操作系统的时候，一个必经的步骤就是--为磁盘分区（C盘、D盘、E盘等），**这些盘也就是文件卷**。每个**文件卷**又分为**目录区**和**文件区**。目录区主要存放文件目录信息（FCB）、用于磁盘储存空间管理的信息，文件区用于存储文件。

一般来说**一块物理磁盘可以划分为多个文件卷**，但是我们可以将**多个物理磁盘划分为一个文件卷**。

先前我们已经讲过非空闲块的管理，现在我们需要知道如何对磁盘的空闲块进行管理，对空闲块的管理有四种方法：
- 空闲表法
- 空闲链法
- 位示图法
- 成组链接法

### 空闲表法

操作系统会维持一张空闲块表，需要分配时查询空闲表进行分配。此方法**适用于文件连续分配的物理结构**

如何分配磁盘块：与内存管理中的动态分区很类似，为**一个文件分配连续的存储空间**。同样可以**采用首次适应、最佳适应、最坏适应等算法**来决定要为文件分配哪个区间

如何回收磁盘块：与内存管理总的动态分区分配很类似，当回首某个存储区时需要有四种情况：
1. 回收区前后都没有相邻空闲区
2. 回收区的前后都是空闲区
3. 回收区前面是空闲区
4. 回收区后面是空闲区

总之，回收时需要注意的就是表项的合并问题

![空闲块表](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%A9%BA%E9%97%B2%E5%9D%97%E8%A1%A8.png)

### 空闲链法

操作系统保持着一个空闲块链表，有**链头和链尾的指针**，需要分配时查询链表。此种方法**适用于文件离散分配的物理结构**，为文件分配多个盘块时可能要重复多次操作

如何分配：若某文件申请K个盘块，则**从链头开始一次摘下K个盘块分配，并修改空闲连的指针**

如何回收：回收的盘块一次挂到链尾，并修改空闲链的链尾指针

![空闲盘块链](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%A9%BA%E9%97%B2%E7%9B%98%E5%9D%97%E9%93%BE.png)

在先前的空闲链法中是将一个一个的空闲块串联到链表上，现在我们可以将一个空闲盘区串联到链表上。此方法**适用于文件离散分配和连续分配**的物理结构

如何分配：若文件申请K个盘块，则可以采用首次适应、最佳适应、最坏适应等算法，从链头开始检索，按照算法规则找到一个符合要求的空闲盘区分配给文件，若没有找到合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后要修改相应的链指针、盘区大小等数据。

如何回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中，若回收区没有和任何空闲区相邻，则将回收区作为单独的一个空闲盘区挂到链尾

![空闲盘区链](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%A9%BA%E9%97%B2%E7%9B%98%E5%8C%BA%E9%93%BE.png)

### 位示图法

每个二进制位对应一个盘块。可以使用0代表空闲，1代表已分配。位示图一般用连续的字来表示，因此可以用字号或位号对应一个盘块号。

如何分配：若文件需要K个块，
1. 顺序扫描位示图，找到K个相邻或不相邻的0
2. 根据字号、位号算出对应的盘块号，将相应盘块分配给文件
3. 将相应位设置为1

如何回收：
1. 根据回收的盘块号计算出相应的字号、位号
2. 将相应二进制位设置为0

![位示图法](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E4%BD%8D%E7%A4%BA%E5%9B%BE%E6%B3%95.png)

### 成组链接法

空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNIX系统中采用了**成组链接法**对磁盘空闲块进行管理。在文件卷的目录区专门用一个磁盘块作为**超级块**，当系统启动时需要将**超级块读入内存**。并且要保证内存和外存中的超级块数据一致。

如何分配：
1. 分配的空闲块数小于第一组空闲盘块数，则分配第一个分组中的1个空闲块，并且修改数据
2. 分配的空闲块数等于第一组空闲盘块数，则分配第一个分组中所有的空闲块，并且将下一组的数据复制到超级块

如何回收：
1. 第一个分组还没满，则将回收的盘块插入到第一个分组之中
2. 第一个分组满了，我们可以将一块新回收的空闲块作为一个新的分组，不过我们需要将超级块中的内容复制到新回收的块之中，超级块将清空并指向新回收的块，再讲多余的空闲块插入到超级块之中

![成组链接法](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%95.png)

-----

## 磁盘的结构

![磁盘结构](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.png)

在学习磁盘的结构的知识时，我们需要先知道几个概念：
- 磁盘：磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据
- 盘面：磁盘从上至下看的一个面，磁盘从上至下有多个盘面，很多个盘面累起来组成了磁盘
- 磁道：磁盘的盘面被划分为一个个同心圆圈，每一个圈就是一个磁道
- 扇区：磁道又被划分为一个个扇区，**每个扇区就是一个磁盘块**，**各个扇区存放的数据量相同**
- 柱面：所有盘面中**相对位置相同的磁道**组成柱面

### 如何在磁盘中读取数据

我们从磁盘中读取数据时，需要把磁头移动到想要读/写的扇区所在的磁道。磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读/写

### 磁盘的物理地址

我们可以使用**（柱面号，盘面号，扇区号）**来定位任意一个磁盘块。在“文件的物理结构”中，我们经常提到的文件数据存放在外存中的几号块，这个块号就可以转换成（柱面号，盘面号，扇区号）的地址形式

可以根据该地址读取一个块：
1. 根据**柱面号**移动磁臂，让磁头指向指定柱面
2. 激活指定盘面的磁头
3. 磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写

### 磁盘的分类

- 磁头可以移动的称为**活动头磁盘**
- 磁头不可移动的称为**固定头磁盘**，这种磁盘中每个磁道有一个磁头。
- 盘片可以更换的称为**可换盘磁盘**
- 盘片不可更换的称为**固定盘磁盘**

-----

## 磁盘调度算法

在了解算法之前，我们先要知道一次磁盘读/写需要的时间：
1. **寻找时间**：在读/写数据前，将磁头移动到指定磁道所花的时间
2. **延迟时间**：通过旋转磁盘，使磁头定位到目标扇区所需要的时间
3. **传输时间**：从磁盘读出或向磁盘写入数据所经历的时间

读/写一次磁盘所需时间为三者之和

### 先来先服务（FCFS）

算法思想：根据进程请求访问磁盘的先后顺序进行调度，先请求的先访问，后请求的后访问

优点：**公平**，如果请求的磁盘比较集中的话，算法性能还勉强过的去</br>
缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间很长

### 最短寻找时间优先（SSTF）

算法思想：会优先处理的磁道是与当前磁头最近的磁道，可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短

优点：性能较好，平均寻道时间短</br>
缺点：在处理一个磁道访问请求时，有源源不断的近磁道的访问请求来临，将会导致远磁道**产生饥饿现象**

### 扫描算法（SCAN）

算法思想：SSTF算法会产生饥饿的原因在于：磁头可能在一个小区域内来回地移动。为了防止这个问题，我们可以规定，**只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动**。由于磁头移动的方式很像电梯，因此也叫作**电梯算法**

优点：性能较好，平均寻道时间短，**不会产生饥饿现象**</br>
缺点：只有到达**最边上的磁道**时才能改变磁头的移动方向。并且对各个位置磁道的响应频率不平均

### LOOK调度算法

算法思想：在SCAN算法中，只有到达最边上的磁道时，才能改变磁头移动方向，事实上，在最后一个磁道访问完了之后，可能不需要到达最边上的磁道。LOOK算法就是解决这个问题，**如果在磁头移动方向上没有别的请求，就可以立刻更换磁头移动方向**

优点：比起SCAN算法，不需要每次都移动到最外侧或者最内侧才改变磁头移动方向，是寻道时间进一步缩短

### 循环扫描算法（C-SCAN）

算法思想：SCAN算法对于各个位置磁道的响应频率不平均，而C-SCAN就是为了解决这个问题。规定只有**磁头朝某个特定方向移动时才能处理磁道访问请求**，而**返回时直接快速移动至起始端而不处理任何请求**

优点：比起SCAN，对于各个位置磁道的响应频率很平均</br>
缺点：只有到达最边上的磁道时才能改变磁头移动方向，比起SCAN算法来，平均寻道时间更长

### C-LOOK调度算法

算法思想：C-SCAN算法的主要缺点就是只到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上，C-LOOL算法就是为了解决这个问题。**如果磁头移动的方向上已经没有磁道访问请求了，就可以立即返回，并且磁头只需要返回到最边缘且有磁道访问请求的位置上即可**

优点：比起C-SCAN算法，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短

-----

## 减少磁盘延迟的方法

总结来说就是：**物理地址结构采用：（柱面号，盘面号，扇区号）；同盘面交替命名；相邻盘面错位命名**

### 交替编号

**问题**：假设要读取橙色区域的2、3、4扇区，磁头读取一个扇区的内容后，需要一小段时间进行处理，而盘片又在不停地旋转。因此，**如果2、3号扇区相邻着排列，则读完2号扇区后无法连续不断的读入3号扇区**，必须等待盘片继续旋转，3号扇区再次划过磁头，才能完成扇区读入

**结论**：磁头读入一个扇区的数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的延迟时间

![减少磁盘延迟](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%87%8F%E5%B0%91%E7%A3%81%E7%9B%98%E5%BB%B6%E8%BF%9F1.png)

为了解决以上问题，我们使用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取的逻辑扇区所需要的逻辑扇区的延迟时间更小

![交替编号](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E4%BA%A4%E6%9B%BF%E7%BC%96%E5%8F%B7.png)

### 磁盘地址结构设计

为什么磁盘的物理地址是（柱面号，盘面号，扇区号），而不是（盘面号，柱面号，扇区号）？

我们假设某磁盘有八个柱面，4个盘面，8个扇区，则可以使用3个二进制位表示柱面，2个二进制位表示盘面，3个二进制位表示扇区，现在我们需要读入连续物理地址为（000,00,000）~（000,01,111）的扇区

若物理地址结构是（柱面号，盘面号，扇区号），由盘面0的磁头读入数据之后在读取物理地址相邻的区域，即（000,01,000）~（000,01,111）由于柱面号相同，只是盘面号不同，因此我们不需要移动磁头臂。只需要激活相邻盘面的磁头即可。**所以采用（柱面号，盘面号，扇区号）的地址结构可以减少磁头移动消耗的时间

### 错位命名

问题：现在盘面与盘面之间扇区都是相对应的当我们读取完（000，00,111）之后，需要读取下一个磁盘块（000,01,000）时，此时刚好第一次划过1号盘面的下方，磁头还未准备就绪，所以并不能立刻读取，只能等该扇区再次划过磁头才能读取

![错位命名1](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E9%94%99%E4%BD%8D%E5%91%BD%E5%90%8D1.png)

为了解决上面的问题我们将相邻两个盘面的扇区进行错位命名，这样就可避免以上问题

![错位命名2](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E9%94%99%E4%BD%8D%E5%91%BD%E5%90%8D2.png)

-----

## 磁盘管理

### 磁盘初始化

1. 进行低级格式化（物理格式化），将磁盘的各个磁道划分为扇区，一个扇区通常可分为头、数据区域、尾三个部分。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码等。
2. 将磁盘分区（C盘、D盘、E盘等），每个分区由若干个柱面组成
3. 进行逻辑格式化，创建文件系统。包括创建文件系统的根目录，初始化存储空间管理所用的数据结构

### 引导块

计算机开机时需要进行一系列初始化工作，这些初始化是通过执行初始化程序（自举程序）完成的。

初始化程序放在ROM中，万一我们需要更新自举程序，将会很不方便，因为ROM中的数据无法更改，那么我们如何解决这个问题呢？

我们在ROM中只存放很小的自举装入程序，完整的自举程序放在磁盘的启动块中，启动块位于磁盘的固定位置，在开机时计算机先运行“自举装入程序”，通过执行该程序就可以找到引导块，并将完整的“自举程序”读入内存，完成初始化，我们也将**拥有引导块的磁盘称为启动磁盘或者系统磁盘（如C盘）*。

### 坏块的管理

对于简单的磁盘，可以在逻辑格式化的时候对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如，在FAT表上标明。但是采用这种方式，坏块对操作系统不透明

对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。在磁盘出厂前进行低级格式化时就将坏块链进行初始化，而且会保留一些备用扇区，用于替换坏块，这种方案称为扇区备用，且这种方式坏块对操作系统透明
