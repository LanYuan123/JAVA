# 文件

-----

## 文件的逻辑结构--文件内部如何组织

所谓的逻辑结构，就是指在用户看来，文件内部的数据应该是如何组织起来的

文件的逻辑结构：
- 无结构文件
- 有结构文件
  - 顺序文件
  - 索引文件
  - 索引顺序文件
  
### 无结构文件

无结构文件：文件内部的数据就是一系列二进制流或字符流组成。又被称为“**流式文件**”

### 有结构文件

有结构文件：由一组相似的记录组成，又称“记录式文件”。每条记录由若干项数据项组成，如数据库表文件。一般来说每条记录有一个数据项可作为关键字（作为识别不同记录的ID）。根据记录的长度又可分为**定长记录**和**可变长记录**

#### 顺序文件

顺序文件：在逻辑上文件中的记录一个接一个地顺序排列，记录可以上**定长**的或者**可变长**的。各个记录在物理上可以**顺序存储**或者**链式存储**

顺序文件又可以分为**串结构**和**顺序结构**。

串结构：记录之间的顺序和关键字无关

顺序结构：记录之间的顺序按照关键字顺序排列

![顺序文件](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6.png)

#### 索引文件

在顺序文件中，可变长记录是无法实现随机访问的，我们使用索引文件可以解决这个问题。

可以为文件本身建立一张索引表，索引表的每个表项记录了每条记录的长度和指向指向记录存放地址的指针，还有索引表本身是定长记录的顺序文件，因此可以快速找到第i个记录对应的索引项。索引表还可以将关键字作为索引号内容，若按照关键字顺序排列则还可以支持按照关键字折半查找。

每当要增加/删除一条记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合

#### 索引顺序文件

在索引文件中，每个记录对应一个索引表项，因此索引表可能会很大。可以使用索引顺序文件来解决这个问题

索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会文件建立一张索引表，但不同的是：并**不是每个记录对应一个索引项**，而是**一组记录对应一个索引表项**。

在索引顺序文件中，我们先将文件的记录进行分组，再为每个分组建立一张索引表，为了**进一步提高检索效率**，可以为顺序文件**建立多级索引表**，即将顺序文件进行多次分组，为每次分组建立索引文件

-----

## 文件的目录结构--文件之间如何组织

### 文件控制块

操作系统为了更好的组织文件，使用文件目录来管理文件，文件目录其实就是一个文件表，**文件表中的每一条记录被称为文件控制块（FCB）**，**一个文件控制块对应着一个文件或者目录的信息**，FCB的有序集合就被称为“文件目录”

### 索引节点（文件控制块的优化）

其实在查找各级目录的过程中只需要用到“文件名”这个信息，只有文件名匹配时，才需要读出文件的其他信息。因此可以考虑让目录“瘦身”来提升效率。即现在一个FCB只包括两项：**文件名**和**索引节点指针**，将FCB的**其他信息存放到索引节点中**。

当找到文件名对应的目录项时，才需要将索引节点调入到内存中，索引节点记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。存放在**外存**中的索引节点称为“**磁盘索引节点**”，当索引节点放入**内存**后被称为“**内存索引节点**”，相比之下内存节点中的信息更多。

![索引节点](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9.png)

### 目录结构

#### 单击目录结构

早期的操作系统并不支持多级目录，因此整个系统之中只建立一张目录表，每个文件占一个目录项

![单级目录](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%8D%95%E7%BA%A7%E7%9B%AE%E5%BD%95.png)

单级目录实现了“按名存取”，但是**不允许文件重名**。在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中。

#### 两级目录结构

显然，以上的**单级目录**结构**不适用于多用户操作系统**

早期的多用户操作系统，采用两级目录结构。分为**主文件目录**和**用户文件目录**。主文件目录记录用户名及相应用户文件目录的存放位置；用户文件目录由该用户的文件FCB组成。两级目录结构允许用户的文件重名，也可以在目录上实现访问限制（检车此时登陆的用户名是否匹配）

![两级目录结构](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E4%B8%A4%E7%BA%A7%E7%9B%AE%E5%BD%95.png)

#### 树形目录结构

以上的两级目录结构缺乏灵活性，用户不能对自己的文件进行分类，所以我们发明了树形目录结构

树形目录结构是一种很常用的树形目录结构，每一个目录下面可以更低一级的目录，也可以有一些普通的文件

![树形目录结构 ](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95.png)

#### 无环图目录结构

**树形目录结构**虽然可以很方便的对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护，但是，树形结构**不便于实现文件的共享**。为此我们提出了**无环图目录结构**

可以用不同的文件名指向同一个文件，甚至可以指向同一个目录（共享同一个目录下的所有内容）。我们需要为每个共享点设置一个共享计数器，用于记录此时有多少个地方在共享该节点，用户提出删除节点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除节点，只有共享计数器减为0时，才会删除节点

![无环图目录结构](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png)

-----

## 文件的物理结构--文件如何存储

类似于内存分页，磁盘中的存储单元也会被分为一个个“块/磁盘块/物理块”。在很多操作系统中，**磁盘块的大小和内存块、页面的大小相同**。由此内存与磁盘之间的数据交换都是以“块”为单位进行的。

类似于内存管理中，进程的逻辑地址空间被分为一个一个页面。同样的，在外存管理中，为了方便对文件数据进行管理，**文件的逻辑地址空间也被分为了一个一个的文件块**，于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式

![文件分配]()

### 连续分配

**连续分配**方式要求**每个文件在磁盘上占有一组连续的块**

逻辑地址->物理地址的转换：只需要通过逻辑地址算出**逻辑块号**和**块内偏移量**。用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项，**从FCB获取到起始块号和分配的磁盘块的长度**，物理块号=起始块号+逻辑块号，再加上块内偏移量就得到了实际的物理地址

![连续分配](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D.png)
![连续分配FCB](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8DFCB.png)

优点：
- 支持**顺序访问**和**随机访问**
- 连续分配的文件在**顺序访问的时候速度最快**

缺点：
- 在读取某个磁盘时，需要移动磁头，访问的两个磁盘块相隔越远，移动磁头所需时间就越长。所以，就连续分配而言：**连续分配的文件在顺序读/写时速度最快**
- 因为连续分配所分配的磁盘块是连续的，所以当文件要扩展但是周围又没有空闲块时，需要将文件全部迁移。结论：**连续分配不方便拓展**
- 采用连续分配，有些小空间无法被利用，**存储空间利用率低，会产生难以利用的磁盘碎片**，可以使用**紧凑**技术来处理碎片，但是需要耗费很大的时间代价

### 链接分配--隐式链接

**链式分配**采用**离散分配**的方式，可以为文件离散的分配磁盘块，这是其中的一种**隐式链接**

当用户要访问文件的时候，首先会在目录表中找到对应FCB，**FCB**中记录文件在磁盘中的**起始块号**和**结束块号**，从FCB中年找到起始块号后，将起始块号读入内存，而该盘块中有保存了下一盘块的指针，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑块，以此类推，可以读出后面所有的内容。

![隐式链接](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E9%9A%90%E5%BC%8F%E9%93%BE%E6%8E%A5.png)

优点：
- 隐式链接很**方便文件拓展**
- 所有的空闲磁盘块的都可以被利用，**不会有碎片的问题，外存利用率高**。

缺点：
- 隐式链接只**支持顺序访问**，**不支持随机访问**，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间

### 链式分配--显式链接

**链式分配**采用**离散分配**的方式，可以为文件离散的分配磁盘块，这是其中的一种**显示链接**

显式链接相较于隐式链接，把用于链接文件各物理块的指针显式的存放在一张表中，即**文件分配表（FAT）**中，在**FCB**中只需要记录文件的**起始块号**即可，FAT表中存放了每一个磁盘块的下一块是什么。

在查找某一个逻辑块时，从FCB中找到起始块号，根据起始块号在内存中查询FAT，往后找到i号逻辑块对应的物理块号。逻辑块号转换成物理块号的过程不需要读磁盘操作

![FAT表](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/FAT.png)

注意：**一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存。**FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的

优点：
- 采用显示链接方式的文件，**支持顺序访问**，**也支持随机访问**，由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，**访问速度快很多**
- **不会产生外部碎片**
- 可以很**方便地对文件进行拓展**

缺点：
- FAT表需要占用一定的存储空间

### 索引分配

索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块。索引表存放的磁盘块称为索引块，文件数据存放的磁盘块称为数据块。在FCB中存放了索引块是几号磁盘块。

逻辑地址->物理地址转换：用户给出需要查找逻辑块号i，操作系统找到该文件对应的FCB，**通过FCB可知索引表存放位置**，将索引表从外存读入内存，并查找索引表即可知道i号逻辑块在外存中的位置。

![索引分配](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D.png)

优点：
- 索引分配方式可以支持随机访问
- 文件拓展也很容易实现（只需要给文件分配一个空闲块，并且增加一个索引表项节课）

缺点：
- 索引表需要占用一定空间

可是当一个文件的索引表大小超过了一个磁盘块，我们怎么办呢？我们有三种解决方式：
- 链接方案
- 多层索引
- 混合索引

#### 链接方案

链接方案：**如果索引表太大，一个索引装不下，那么可以将多个索引块如先前的隐式链接一般链接起来存放**。每个索引块会分配一定的空间存储下一个索引块的指针。

缺点：若文件很大，索引表很长，就需要将很多个索引块链接起来。想要找到i号索引块，必须依次读入0~i-1号索引块，这就导致**I/O次数过多**，**查找效率很低**

![链接方案](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E9%93%BE%E6%8E%A5%E6%96%B9%E6%A1%88.png)

#### 多层索引

显然上面的链接方案是十分低效的，所以人们又提出了多层索引

多层索引：建立多层索引（**原理类似于多级页面**）。是第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。

缺点：**即使是小文件，访问一个数据块依然需要K+1次读磁盘**

![多层索引](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%A4%9A%E5%B1%82%E7%B4%A2%E5%BC%95.png)

#### 混合索引

混合索引：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含**直接抵制索引**（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级简介索引（指向两层索引表）。

![混合索引](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%B7%B7%E5%90%88%E7%B4%A2%E5%BC%95.png)

-----

## 操作系统提供的关于文件的系统调用

### 创建文件（create系统调用）

进行create系统调用时，需要提供的几个主要参数：
1. 所需外存空间的大小
2. 文件存放路径
3. 文件名

操作系统在处理Create系统调用时，主要做了两件事：
1. **在外存中找到文件所需的空间**
2. 根据文件存放路径的信息找到该目录对应的目录文件，在目录中创建该文件的FCB。FCB包含了文件名、文件在外存中的存放位置等等

### 删除文件（delete系统调用）

进行Delete系统调用时，需要提供的几个主要参数：
1. 文件存放路径
2. 文件名

操作系统在处理Delete系统调用时，主要做了几件事：
1. 根据文件存放路径找到对应的目录文件，从目录文件中找到对应的FCB。
2. 根据FCB记录的文件外存存放文职、文件大小等信息，回收文件占用的磁盘块
3. 从目录表中删除文件对应的目录项

### 打开文件（open系统调用）

很多操作系统中，对文件进行操作之前，要求对文件先使用Open系统调用打开文件，进行Open系统调用时，需要提供的几个主要参数：
1. 文件存放路径
2. 文件名
3. 要对文件进行的操作类型

操作系统在处理系统调用时，主要做了几件事：
1. 根据文件存放路径找到对应的目录文件，从目录文件中找到对应的FCB。并且检查用户是否有操作权限
2. 将目录项复制到内存中的打开文件表中，并将对应表目的编号返回给用户，之后用户使用打开文件表的编号指明要操作的文件

![打开文件](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6.png)

系统有两种打开文件表：属于某个进程的打开文件表和系统的打开文件表。系统的打开文件表其实是方便我们实现文件管理的功能。比如：我们要删除某个txt文件，但是如果此时该文件已被某个“记事本”进程打开，则系统会提示我们暂时无法删除该文件。其实系统在背后就是先检查了系统打开文件表。确认此事是否有进程正在使用该文件

![两种打开文件表](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E4%B8%A4%E7%A7%8D%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E8%A1%A8.png)

### 关闭文件（close系统调用）

操作系统在处理Close系统调用时，主要做了几件事：
1. 将进程的打开文件表相应表项删除
2. 回收分配给该文件的内存空间等资源
3. 系统打开文件表的打开计数器count减1，若count=0，则删除对应表项


### 读文件（read系统调用）

进行Read系统调用时，需要指明是哪个文件（在支持打开文件操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明要读入多少数据、指明读入的数据要放在内存中的什么位置

操作系统在处理Read系统调用时，从读指针指向的外存区域中，将用户指定大小的数据读入用户指定的内存区域中

### 写文件（write系统调用）

进行系统调用时，需要指明是哪个文件（在支持打开文件操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明要写多少数据、写回外存的数据放在内存中什么位置

操作系统在处理系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存
 
-----

## 文件共享

操作系统为用户提供文件共享功能，可以让多个用户共享地使用同一个文件，文件共享的方式有两种，**基于索引节点共享的硬链接**和**基于符号链共享的软链接**。

### 基于索引节点的共享

我们可以在索引节点中设置一个链接计数变量count，用于表示链接到本索引节点上的用户目录项数。若count2，说明此时有两个用户目录项链接到该索引节点上，或者说有两个用户在共享此文件。若某个用户决定“删除”该文件，则只是吧用户目录中与该文件对应的目录项删除，且索引节点的count值减1。若count>0，说明还有用户在使用该文件，不能见文件数据删除，否则指针会悬空，当count=0时才删除文件数据

![索引节点共享](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E5%85%B1%E4%BA%AB.png)

### 基于符号链的共享

索引节点指向的会是一个Link类型的文件，该文件记录了共享文件存放的地址，操作系统会根据该地址找到共享文件，从而实现共享。类似于Windows的快捷方式。

如果共享文件被删除了，则Link文件指向的地址就会找不到该文件

![符号链共享](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%AC%A6%E5%8F%B7%E9%93%BE%E5%85%B1%E4%BA%AB.png)

-----

## 文件保护

### 口令保护

为文件设置一个“口令”，用户请求访问该文件时必须提供“口令”

口令一般存放在文件对应的FCB或索引节点中。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确，则允许该用户访问文件

优点：保存口令的空间开销不多，验证口令的时间开销也很小

缺点：正确的“口令”存放在系统内部，不够安全，如果系统被攻破，则口令也会泄露

### 加密保护

使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密

“密码”和“口令”不同，口令对文件本身没有影响，而密码对文件本身的原始数据进行加密。

优点：保密性强，不需要在系统中存储“密码”

缺点:编码/译码，或者说加密/解密要花费一定时间

### 访问控制

在每个文件的FCB（或者索引节点）中增加一个访问控制列表，该表中记录了各个用户可以对该文件执行哪些操作。

![访问控制](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8.png)

有的计算机可能会有很多个用户，因此访问控制列表可能会很大，可以用精简的访问列表解决。

精简的访问列表：以“组”为单位，标记个“组”用户可以对文件执行哪些操作。当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限。

![精简的访问控制](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%B2%BE%E7%AE%80%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8.png)

-----

# 外存

-----

## 外存空闲块管理

我们在安装操作系统的时候，一个必经的步骤就是--为磁盘分区（C盘、D盘、E盘等），**这些盘也就是文件卷**。每个**文件卷**又分为**目录区**和**文件区**。目录区主要存放文件目录信息（FCB）、用于磁盘储存空间管理的信息，文件区用于存储文件。

一般来说**一块物理磁盘可以划分为多个文件卷**，但是我们可以将**多个物理磁盘划分为一个文件卷**。

先前我们已经讲过非空闲块的管理，现在我们需要知道如何对磁盘的空闲块进行管理，对空闲块的管理有四种方法：
- 空闲表法
- 空闲链法
- 位示图法
- 成组链接法

### 空闲表法

操作系统会维持一张空闲块表，需要分配时查询空闲表进行分配。此方法**适用于文件连续分配的物理结构**

如何分配磁盘块：与内存管理中的动态分区很类似，为**一个文件分配连续的存储空间**。同样可以**采用首次适应、最佳适应、最坏适应等算法**来决定要为文件分配哪个区间

如何回收磁盘块：与内存管理总的动态分区分配很类似，当回首某个存储区时需要有四种情况：
1. 回收区前后都没有相邻空闲区
2. 回收区的前后都是空闲区
3. 回收区前面是空闲区
4. 回收区后面是空闲区

总之，回收时需要注意的就是表项的合并问题

![空闲块表](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%A9%BA%E9%97%B2%E5%9D%97%E8%A1%A8.png)

### 空闲链法

操作系统保持着一个空闲块链表，有**链头和链尾的指针**，需要分配时查询链表。此种方法**适用于文件离散分配的物理结构**，为文件分配多个盘块时可能要重复多次操作

如何分配：若某文件申请K个盘块，则**从链头开始一次摘下K个盘块分配，并修改空闲连的指针**

如何回收：回收的盘块一次挂到链尾，并修改空闲链的链尾指针

![空闲盘块链](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%A9%BA%E9%97%B2%E7%9B%98%E5%9D%97%E9%93%BE.png)

在先前的空闲链法中是将一个一个的空闲块串联到链表上，现在我们可以将一个空闲盘区串联到链表上。此方法**适用于文件离散分配和连续分配**的物理结构

如何分配：若文件申请K个盘块，则可以采用首次适应、最佳适应、最坏适应等算法，从链头开始检索，按照算法规则找到一个符合要求的空闲盘区分配给文件，若没有找到合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后要修改相应的链指针、盘区大小等数据。

如何回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中，若回收区没有和任何空闲区相邻，则将回收区作为单独的一个空闲盘区挂到链尾

![空闲盘区链](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%A9%BA%E9%97%B2%E7%9B%98%E5%8C%BA%E9%93%BE.png)

### 位示图法

每个二进制位对应一个盘块。可以使用0代表空闲，1代表已分配。位示图一般用连续的字来表示，因此可以用字号或位号对应一个盘块号。

如何分配：若文件需要K个块，
1. 顺序扫描位示图，找到K个相邻或不相邻的0
2. 根据字号、位号算出对应的盘块号，将相应盘块分配给文件
3. 将相应位设置为1

如何回收：
1. 根据回收的盘块号计算出相应的字号、位号
2. 将相应二进制位设置为0

![位示图法](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E4%BD%8D%E7%A4%BA%E5%9B%BE%E6%B3%95.png)

### 成组链接法

空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNIX系统中采用了**成组链接法**对磁盘空闲块进行管理。在文件卷的目录区专门用一个磁盘块作为**超级块**，当系统启动时需要将**超级块读入内存**。并且要保证内存和外存中的超级块数据一致。

如何分配：
1. 分配的空闲块数小于第一组空闲盘块数，则分配第一个分组中的1个空闲块，并且修改数据
2. 分配的空闲块数等于第一组空闲盘块数，则分配第一个分组中所有的空闲块，并且将下一组的数据复制到超级块

如何回收：
1. 第一个分组还没满，则将回收的盘块插入到第一个分组之中
2. 第一个分组满了，我们可以将一块新回收的空闲块作为一个新的分组，不过我们需要将超级块中的内容复制到新回收的块之中，超级块将清空并指向新回收的块，再讲多余的空闲块插入到超级块之中

![成组链接法](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%95.png)

-----

## 磁盘的结构

-----

## 磁盘调度算法

-----

## 减少磁盘延迟的方法

-----

## 磁盘管理
