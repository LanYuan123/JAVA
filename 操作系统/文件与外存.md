# 文件

-----

## 文件的逻辑结构--文件内部如何组织

所谓的逻辑结构，就是指在用户看来，文件内部的数据应该是如何组织起来的

文件的逻辑结构：
- 无结构文件
- 有结构文件
  - 顺序文件
  - 索引文件
  - 索引顺序文件
  
### 无结构文件

无结构文件：文件内部的数据就是一系列二进制流或字符流组成。又被称为“**流式文件**”

### 有结构文件

有结构文件：由一组相似的记录组成，又称“记录式文件”。每条记录由若干项数据项组成，如数据库表文件。一般来说每条记录有一个数据项可作为关键字（作为识别不同记录的ID）。根据记录的长度又可分为**定长记录**和**可变长记录**

#### 顺序文件

顺序文件：在逻辑上文件中的记录一个接一个地顺序排列，记录可以上**定长**的或者**可变长**的。各个记录在物理上可以**顺序存储**或者**链式存储**

顺序文件又可以分为**串结构**和**顺序结构**。

串结构：记录之间的顺序和关键字无关

顺序结构：记录之间的顺序按照关键字顺序排列

![顺序文件](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6.png)

#### 索引文件

在顺序文件中，可变长记录是无法实现随机访问的，我们使用索引文件可以解决这个问题。

可以为文件本身建立一张索引表，索引表的每个表项记录了每条记录的长度和指向指向记录存放地址的指针，还有索引表本身是定长记录的顺序文件，因此可以快速找到第i个记录对应的索引项。索引表还可以将关键字作为索引号内容，若按照关键字顺序排列则还可以支持按照关键字折半查找。

每当要增加/删除一条记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合

#### 索引顺序文件

在索引文件中，每个记录对应一个索引表项，因此索引表可能会很大。可以使用索引顺序文件来解决这个问题

索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会文件建立一张索引表，但不同的是：并**不是每个记录对应一个索引项**，而是**一组记录对应一个索引表项**。

在索引顺序文件中，我们先将文件的记录进行分组，再为每个分组建立一张索引表，为了**进一步提高检索效率**，可以为顺序文件**建立多级索引表**，即将顺序文件进行多次分组，为每次分组建立索引文件

-----

## 文件的目录结构--文件之间如何组织

### 文件控制块

操作系统为了更好的组织文件，使用文件目录来管理文件，文件目录其实就是一个文件表，**文件表中的每一条记录被称为文件控制块（FCB）**，**一个文件控制块对应着一个文件或者目录的信息**，FCB的有序集合就被称为“文件目录”

### 索引节点（文件控制块的优化）

其实在查找各级目录的过程中只需要用到“文件名”这个信息，只有文件名匹配时，才需要读出文件的其他信息。因此可以考虑让目录“瘦身”来提升效率。即现在一个FCB只包括两项：**文件名**和**索引节点指针**，将FCB的**其他信息存放到索引节点中**。

当找到文件名对应的目录项时，才需要将索引节点调入到内存中，索引节点记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。存放在**外存**中的索引节点称为“**磁盘索引节点**”，当索引节点放入**内存**后被称为“**内存索引节点**”，相比之下内存节点中的信息更多。

![索引节点](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9.png)

### 目录结构

#### 单击目录结构

早期的操作系统并不支持多级目录，因此整个系统之中只建立一张目录表，每个文件占一个目录项

![单级目录](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%8D%95%E7%BA%A7%E7%9B%AE%E5%BD%95.png)

单级目录实现了“按名存取”，但是**不允许文件重名**。在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中。

#### 两级目录结构

显然，以上的**单级目录**结构**不适用于多用户操作系统**

早期的多用户操作系统，采用两级目录结构。分为**主文件目录**和**用户文件目录**。主文件目录记录用户名及相应用户文件目录的存放位置；用户文件目录由该用户的文件FCB组成。两级目录结构允许用户的文件重名，也可以在目录上实现访问限制（检车此时登陆的用户名是否匹配）

![两级目录结构](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E4%B8%A4%E7%BA%A7%E7%9B%AE%E5%BD%95.png)

#### 树形目录结构

以上的两级目录结构缺乏灵活性，用户不能对自己的文件进行分类，所以我们发明了树形目录结构

树形目录结构是一种很常用的树形目录结构，每一个目录下面可以更低一级的目录，也可以有一些普通的文件

![树形目录结构 ](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95.png)

#### 无环图目录结构

**树形目录结构**虽然可以很方便的对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护，但是，树形结构**不便于实现文件的共享**。为此我们提出了**无环图目录结构**

可以用不同的文件名指向同一个文件，甚至可以指向同一个目录（共享同一个目录下的所有内容）。我们需要为每个共享点设置一个共享计数器，用于记录此时有多少个地方在共享该节点，用户提出删除节点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除节点，只有共享计数器减为0时，才会删除节点

![无环图目录结构](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png)

-----

## 操作系统提供的关于文件的系统调用

-----

## 文件共享

-----

## 文件保护

-----

# 外存

-----

## 文件的物理结构--外存非空闲块管理

类似于内存分页，磁盘中的存储单元也会被分为一个个“块/磁盘块/物理块”。在很多操作系统中，**磁盘块的大小和内存块、页面的大小相同**。由此内存与磁盘之间的数据交换都是以“块”为单位进行的。

类似于内存管理中，进程的逻辑地址空间被分为一个一个页面。同样的，在外存管理中，为了方便对文件数据进行管理，**文件的逻辑地址空间也被分为了一个一个的文件块**，于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式

### 连续分配

**连续分配**方式要求**每个文件在磁盘上占有一组连续的块**

逻辑地址->物理地址的转换：只需要通过逻辑地址算出**逻辑块号**和**块内偏移量**。用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项，**从FCB获取到起始块号和分配的磁盘块的长度**，物理块号=起始块号+逻辑块号，再加上块内偏移量就得到了实际的物理地址

![连续分配](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D.png)
![连续分配FCB](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8DFCB.png)

优点：
- 支持**顺序访问**和**随机访问**
- 连续分配的文件在**顺序访问的时候速度最快**

缺点：
- 在读取某个磁盘时，需要移动磁头，访问的两个磁盘块相隔越远，移动磁头所需时间就越长。所以，就连续分配而言：**连续分配的文件在顺序读/写时速度最快**
- 因为连续分配所分配的磁盘块是连续的，所以当文件要扩展但是周围又没有空闲块时，需要将文件全部迁移。结论：**连续分配不方便拓展**
- 采用连续分配，有些小空间无法被利用，**存储空间利用率低，会产生难以利用的磁盘碎片**，可以使用**紧凑**技术来处理碎片，但是需要耗费很大的时间代价

### 链接分配--隐式链接

**链式分配**采用**离散分配**的方式，可以为文件离散的分配磁盘块，这是其中的一种**隐式链接**

当用户要访问文件的时候，首先会在目录表中找到对应FCB，**FCB**中记录文件在磁盘中的**起始块号**和**结束块号**，从FCB中年找到起始块号后，将起始块号读入内存，而该盘块中有保存了下一盘块的指针，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑块，以此类推，可以读出后面所有的内容。

![隐式链接](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E9%9A%90%E5%BC%8F%E9%93%BE%E6%8E%A5.png)

优点：
- 隐式链接很**方便文件拓展**
- 所有的空闲磁盘块的都可以被利用，**不会有碎片的问题，外存利用率高**。

缺点：
- 隐式链接只**支持顺序访问**，**不支持随机访问**，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间

### 链式分配--显式链接

**链式分配**采用**离散分配**的方式，可以为文件离散的分配磁盘块，这是其中的一种**显示链接**

显式链接相较于隐式链接，把用于链接文件各物理块的指针显式的存放在一张表中，即**文件分配表（FAT）**中，在**FCB**中只需要记录文件的**起始块号**即可，FAT表中存放了每一个磁盘块的下一块是什么。

在查找某一个逻辑块时，从FCB中找到起始块号，根据起始块号在内存中查询FAT，往后找到i号逻辑块对应的物理块号。逻辑块号转换成物理块号的过程不需要读磁盘操作

![FAT表](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/FAT.png)

注意：**一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存。**FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的

优点：
- 采用显示链接方式的文件，**支持顺序访问**，**也支持随机访问**，由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，**访问速度快很多**
- **不会产生外部碎片**
- 可以很**方便地对文件进行拓展**

缺点：
- FAT表需要占用一定的存储空间

### 索引分配

-----

## 外存空闲块管理

-----

## 磁盘的结构

-----

## 磁盘调度算法

-----

## 减少磁盘延迟的方法

-----

## 磁盘管理
