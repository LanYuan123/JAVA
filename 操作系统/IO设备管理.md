# IO设备管理

-----

## IO设备的概念及分类

I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件，UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作

### 按使用特性分

1. 人机交互类外部设备：鼠标、键盘、打印机等
2. 存储设备：移动硬盘、光盘等
3. 网络通讯设备：调制解调器等

### 安传输速率分

1. 低速设备：鼠标、键盘等
2. 中速设备：如激光打印机
3. 高速设备：如磁盘等

### 按信息交换的单位分

1. 块设备：如磁盘等
2. 字符设备：如鼠标、键盘等

-----

## IO控制器

I/O设备由两部分组成，一部分是机械部件，一部分是电子部件。IO设备的**机械部件主要用来执行I/O操作**，如我们看得见摸得着的鼠标/键盘的按钮；显示屏的LED屏；移动硬盘的磁臂、磁盘盘面。IO设备的**电子部件通常是一块插入主板扩充槽的印刷电路板**。

CPU无法之间控制IO设备的机械部件，因此IO设备还要一个电子部件作为CPU和IO设备机械部件之间的中介，用于实现CPU对设备的控制。**这个电子部件就是IO控制器，又称为设备控制器**。CPU可控制IO控制器，又由控制器来控制设备的机械部件。

### IO控制器的功能

1. 接受和识别CPU发出的命令
2. 向CPU报告设备的状态
3. 数据交换
4. 地址识别

### IO控制器的组成

1. CPU和控制器的接口：实现CPU和IO控制器之间的通讯；通过地址线指明要操作的设备；通过数据线来取出和放入数据
2. IO逻辑：负责接收和识别CPU的各种命令，并负责对设备发出命令
3. 控制器和设备的接口：用于实现控制器和设备之间的通信

![IO控制器](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/IO%E6%8E%A7%E5%88%B6%E5%99%A8.png)

我们需要注意几个细节：
1. 一个IO控制器可能会对应多个设备
2. 数据寄存器、控制寄存器、状态寄存器可能有多个，且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些**寄存器占用内存地址**的一部分，称为**内存映像**；另一些计算机则采用**IO专用地址**，即**寄存器独立编址**

内存映像IO：控制器中的寄存器与内存地址统一编址

优点：简化了指令。可以采用对内存进行操作的指令来对控制器进行操作

![内存IO映像](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F.png)

寄存器独立编址：控制器中的寄存器使用单独的地址

缺点：需要设置专门的指令来实现对控制器的操作，不仅要指明寄存器的地址，还要指明控制器的编号

![寄存器独立编址](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%AF%84%E5%AD%98%E5%99%A8%E7%8B%AC%E7%AB%8B%E7%BC%96%E5%9D%80.png)

-----

## IO控制方式

对于我们怎样控制IO设备对数据的读写，我们需要注意以下几个问题：
1. 完成一次读/写操作的流程
2. CPU干涉的频率
3. 数据传送的单位
4. 数据的流向
5. 主要缺点和优点

我们有4种IO控制方式：
1. 程序直接控制方式
2. 中断驱动方式
3. DMA方式
4. 通道控制方式

![IO控制方式](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/IO%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.png)

### 程序直接控制方式

key words：**轮询**

![程序直接控制](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6.png)

下面来看看进行一次读操作需要进行的操作：
1. **CPU**通过**控制线**向控制器发送读指令。于是设备启动，并且状态寄存器设置为**未就绪状态**
2. CPU**轮询检查控制器的状态**（其实就是不断的执行程序的循环），如果其状态位一直是1，说明设备还没准备好要输入的数据，于是CPU会不断地轮询
3. 输入设备**准备好数据**后将数据传给控制器，并报告自身状态
4. 控制器将输入的数据放入到数据寄存器中，并将状态改为**已就绪**
5. CPU发现设备已经**就绪**，即可将**数据寄存器**中的内容读入**CPU的寄存器**中，再把CPU寄存器中的内容放入内存
6. 若还要继续读入数据，则CPU继续发出读指令

![程序直接控制流程图](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

- CPU的干涉频率：**很频繁**，IO操作开始之前，**完成之后需要CPU的介入，并且在等待IO完成的过程中CPU需要不断的轮询检查**
- 每次读/写**一个字**
- 数据的流向：
  - 数据输入：IO设备->CPU->内存
  - 数据输出：内存->CPU->IO设备
- 主要优点：实现简单，在读/写指令之后，加上实现循环检查的一系列指令即可
- 主要缺点：CPU和IO设备只能串行工作，**CPU**需要一直轮询检查，**长期处于忙等状态**

### 中断驱动方式

鉴于以上方式的一部分去缺点，我们引入**中断机制**，由此，**CPU在发出指令后，可将等待IO的进程阻塞，先切换到别的进程执行**。当IO完成后，控制器会向CPU发出一个中断信号，**CPU检测到中断信号**，会保存当前进程的运行环境信息，转去执行中断处理程序处理中断。处理中断的过程中，CPU从IO控制器读一个字的数据传送到CPU的寄存器，在写入主存。接着，CPU恢复等待IO的进程的运行环境，然后继续执行

注意：
1. CPU会在每个指令周期的末尾检查中断
2. 中断处理过程中需要保存、恢复进程的运行环境，这个过程会有一定的时间开销，可见，如果中断的频率太高，也会降低系统性能

![中断驱动流程图](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

- CPU干预频率：**每次读写开始之前、完成之后需要CPU介入**，等待过程CPU可以为其他进程服务
- 每次读/写一个字
- 数据的流向：
  - 数据输入：IO设备->CPU->内存
  - 数据输出：内存->CPU->IO设备
- 主要优点：相比于“程序直接控制方式”，IO控制器会通过中断信号主动报告IO已完成，**CPU不再需要不停地轮询**
- 主要缺点：每个字在IO设备与内存之间的传输，都需要经过CPU。而**频繁的中断处理需要消耗较多的CPU时间**

### DMA方式

与“中断驱动方式”相比，DMA方式（**直接存储器存取**，主要用于块设备IO控制）有这样一些改进：
1. 数据的**传送单位是“块”**、不再是一个字、一个字的传送
2. 数据的流向是从设备直接放入内存，或者直接从内存到设备，**不需要途径CPU**
3. 仅在传送一个或者多个数据块的**开始和结束时，才需要CPU的干预**

![DMA流程图](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/DMA%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

DMA方式使DMA控制器来实现，DMA控制器同样也是IO控制器，只是和普通的IO控制器有一定的区别，但他同样也是有IO逻辑、与CPU接口、与设备接口三个部分组成

![DMA](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/DMA.png)

- **DR（数据寄存器）**：暂时从设备到内存，或从内存到设备的数据
- **MAR（内存地址寄存器）**：在输入时，MAR表示数据应放到内存的什么位置；在输出时，表示要输出的数据放在内存的什么位置
- **DC（数据计数器）**：表示剩余要读/写的字节数
- **CR（命令/状态寄存器）**：存放CPU发来的IO命令，或者是设备的状态信息

**CPU、内存、DMA控制器三者通过系统总线连接在一起，这样内存可以和DMA控制器直接转发，而不需要经过CPU转发，CPU也只需要发送命令和表名需要将数据放到内存的什么地方或者从内存的什么地方读入数据**，这样CPU就可以从转发数据中解放出来，内存也可以和DMA控制器直接交互

- CPU干预的频率：尽在传送数据块开始和结束的时候，才需要CPU干预
- 数据传送单位：每次读/写**一个或多个块（每次读写的只能是连续的多个块，且这些块读入内存之后在内存中也必须是连续的）**
- 数据的流向：
  - 数据输入：IO设备->内存
  - 数据输出：内存->IO设备
- 主要优点：**数据输出以“块”为单位，CPU的介入频率再进一步降低**。**数据的传输可以跳过CPU**，传输效率提升。CPU和IO的并行性等到提升
- 主要缺点：CPU没发出一条IO指令，只能读写一个或多个**连续的**数据块。如果读写多个离散存储的数据块，或者将数据分别写到不同的内存区域时，CPU要分别发出多条IO指令，进行多次中断处理才能完成

### 通道控制方式

为了解决DMA的缺点，我们使用通道控制方式。

通道：一种硬件，可以理解为“**弱鸡版CPU”**。通道可以识别并执行一系列**通道指令**

![通道控制](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6.png)

1. CPU**向通道发出IO指令**，**指明通道程序在内存中的位置**，并且**指明要操作哪个IO设备**。之后CPU切换到其他进程运行
2. **通道执行内存中的通道程序**（其中指明要读入/写出多少数据，读/写的数据应该放在内存的什么位置等信息）
3. 通道执行完规定任务后，向CPU发送中断信号，之后CPU对中断进行处理

- CPU干预频：极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读写后才需要发出中断信号，请求CPU的干预
- 数据传送单位：每次读写一组数据
- 数据流向：
  - 数据输入：IO设备->内存
  - 数据输出：内存->IO设备
- 主要缺点：**实现复杂**，需要专门的通道硬件
- 主要优点：**CPU、通道、IO设备可以并行工作，资源利用率高**

-----

## IO软件层次结构

![IO软件层次结构](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/IO%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png)

在IO软件层级结构中一共可以分为五层，**中间的三层属于操作系统内核部分**，称为**IO核心子系统**：
1. 用户层软件：**实现了与用户交互的接口**，向上层提供库函数，用户层软件将用户请求翻译成格式化的IO请求，并通过“系统调用”请求操作系统内核的服务
2. 设备独立性软件；向上层提供**系统调用**，提供**设备保护**，对设备进行**差错处理**，**设备的回收与分配**，**数据缓冲区管理**，建立逻辑设备名刀物理设备名的映射关系，并且根据设备类型调用响应的驱动程序。在建立映射关系时，系统会维持一张**逻辑设备表（LUT）**。有两种管理方式：
  - **整个系统只设置一张LUT**，这意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统
  - **为每个用户设置一张LUT**，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中
3. 设备驱动程序：主要负责对硬件设备的具体控制，将上层发出的一系列指令转化为特定设备能听得懂的一系列操作，包括设置设备寄存器，检查设备状态等
4. 中断处理程序：IO控制器发出中断信号之后，系统会根据中断信号类型找到相应的中断处理程序并执行，中断处理程序会和硬件直接打交道
5. 硬件

**越上面的层次越接近用户**，**越下面的层次越接近硬件**，并且每层会为上层提供服务，并且屏蔽调某些具体细节。

-----

## 假脱机技术

在了解假脱机技术之前，我们需要先知道什么是脱机技术。在以前手工操作的阶段，主机直接从IO设备获得数据，由于设备速度慢，主机速度很快。人机速度矛盾明显，主机要浪费很多时间来等待设备。于是我们在批处理阶段引入脱机输入/输出技术（使用磁带完成），在设备与主机之间加入一个外围控制机，在外围控制机的控制之下，慢速输入设备的数据先被输入到更快捷的磁带上。之后主机可以从快速的磁带上读入数据，从而缓解了速度矛盾。

为什么称以上的技术为脱机技术，那是因为脱离了主机的控制进行的输入/输出操作。

我们的假脱机技术，又称之为“SPOOLing技术”是用软件的方式模拟脱机技术。SPOOLing系统的组成如下：

![SPOOLing技术](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/SPOOLing%E6%8A%80%E6%9C%AF.png)

我们可以运用SPOOLing技术将独占式设备改造成共享式设备

当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们，而是由假脱机管理进程为每个进程做两件事：
1. 在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的），并将要打印的数据送入其中
2. 为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再讲该表挂在假脱机文件队列上
3. 当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印，用这种方式可以依次处理完全部的打印任务

使用了SPOOLing技术之后，虽然系统中只有一台打印机，但是每个进程提出打印请求时，系统都会为其在输出井中分配一个存储区，使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。这就将一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享式设备

-----

## 设备的分配与回收

### 设备分配时应该考虑的因素

设备的固有属性：
1. 独占设备：一个时段只能分配给一个进程
2. 共享设备：可同时分配给多个进程使用，各进程往往是宏观上同时共享使用设备，而微观上交替使用
3. 虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用

设备的分配算法：
1. 先来先服务
2. 优先级高者优先
3. 短任务优先
4. .....

设备分配中的安全性：
1. **安全分配方式**：为进程分配一个设备后就将进程阻塞，本次IO完成后才能将进程唤醒
  - 优点：破坏了请求和保持条件，不会死锁
  - 缺点：对一个进程来说，CPU和IO设备只能串行执行
2. **不安全分配方式**：进程发出IO请求后，系统为其分配IO设备，进程可继续执行，之后还可以发出新的IO请求，只有某个IO请求得不到满足时才能将进程阻塞
  - 优点：进程的计算任务和IO任务可以并行处理，使进程迅速地推进
  - 缺点：有可能发生死锁
  
设备的分配：
1. 静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源
2. 动态分配：进程运行过程中动态申请设备资源

### 设备分配管理中的数据结构

设备、控制器、通道之间的关系：

![设备分配的数据结构](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png)

一个通道可控制多个设备控制器，每个设备控制器可控制多个设备

**设备控制表（DCT）**：系统为每个设备配置一张DCT，用于记录设备情况

![DCT](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/DCT.png)

**控制器控制表（COCT）**：每个设备控制器都会对应一张COCT。操作系统会根据COCT的信息对控制器进行操作和管理

![COCT](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/COCT.png)

**通道控制表**：每个通道对应一张CHCT，操作系统根据CHCT的信息对通道进行操作和管理

![CHCT](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/CHCT.png)

**系统设备表**：记录了系统中全部设备的情况，每个设备对应一个表目。

![SDT](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/SDT.png)

### 设备分配的步骤

1. 根据进程请求的**物理设备名**查找SDT
2. 根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程
3. 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程
4. 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程

只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动IO设备进行数据传送

设备分配步骤的改进：
1. 根据进程请求的逻辑设备名查找SDT（其实就是“设备类型”）
2. 查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给进程，操作系统在逻辑设备表中新增一个表项
3. 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程
4. 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程

-----

## 缓冲区管理

缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。使用**硬件作为缓冲区**的**成本较高**，**容量较小**，一般仅用在对速度要求非常高的场合（如页表的快表所用的联想寄存器）。一般情况下，我们更多利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区

缓冲区的作用：
1. **缓冲CPU与IO设备之间速度不匹配的矛盾**
2. **减少对CPU的中断频率，放宽对CPU中断相应时间的限制**，这就是DMA和通道方式可以一次输入一个或多个块的原因
3. **解决数据粒度不匹配的问题**
4. **提高CPU和IO设备之间的并行性**

注意：**当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但是必须要把缓冲区充满之后，才能从缓冲区把数据传出。**

### 单缓冲区

当用户进程请求某块设备的时候，操作系统会在**主存中为其分配一个缓冲区**

### 双缓冲区

当用户进程请求某块设备的时候，操作系统会在**主存中为其分配两个个缓冲区**

### 循环缓冲区

当用户进程请求某块设备的时候，操作系统会在**将多个缓冲区链接成一个循环队列**，并且维持两个指针，一个in指针，指向下一个可以冲入数据的空闲缓冲区，一个out指针，指向下一个可以去除数据的满缓冲区

![循环缓冲区](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2%E5%8C%BA.png)

### 缓冲池

缓冲池由系统中共用的缓冲区。这些缓冲区按使用状况可以分为：空缓冲队列、装满输入数据的缓冲队列、装满输出数据的缓冲队列、装满输出数据的缓冲队列

另外根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：用于收容输入数据的工作缓冲区（hin）、用于提取输入数据的工作缓冲区（sin）、用于收容输出数据的工作缓冲区（hout）、用于提取输出数据的工作缓冲区（sout）

![缓冲区池](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%BC%93%E5%86%B2%E6%B1%A0.png)
