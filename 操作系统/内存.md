# 内存

程序的运行必须先放入到内存当中，但是代码究竟是如何放入到内存中的呢？内存又是如何分配的呢？内存是怎样保证进程之间不能访问对方内存空间的？程序是怎样获取数据在内存中的位置的？这些就是我们将要在内存这一章节将要研究的问题。

- 内存的地址转换
- 内存地址空间的扩展
- 内存的分配与回收
- 内存的存储保护

## 内存的地址转换

## 内存的地址空间扩展

## 内存的分配与回收

内存的地址分配有两种方式，一种是连续地址分配，一种是非连续地址分配。连续分配是指为用户分配的必须是一个连续的内存空间，而非连续的地址分配，地址空间可以是不连续，离散的

### 连续分配：单一连续分配

在这种地址分配方式中，内存分为**系统区**和**用户区**。系统区通常位于内存的低地址部分，用于存放操作系统的相关数据。用户区用于存放用户程序数据，**用户区中只能有一道用户程序**，用户程序独占整个用户区空间

![单一连续分配](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%8D%95%E4%B8%80%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D.png)

- **优点**：实现简单，**没有外部碎片**；可以采用覆盖技术扩充内存；不一定需要采取内存保护
- **缺点**：只能用于单用户、单任务的操作系统中；**有内部碎片**；存储器利用率极低

### 连续分配：固定分区分配

为了能在内存中装入多道程序，并且这些程序之间又不会相互干扰，我们**将整个用户空间划分为若干个固定大小的分区**，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式

固定分区分配：
- 分区大小相等
- 分区大小不等

![固定分区分配方式](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D.png)

**分区大小相等**：缺乏灵活性，但是有时却很适合用于用一台计算机控制多个相同对象的场合(比如钢铁厂有n个相同的炼钢炉，可以将内存分为n个大小相等的区域放n个炼钢炉控制程序)

**分区大小不等**：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分

对于固定分区分配，操作系统需要建立一个数据结构--分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常安分区大小来排列，每个表项包括对应分区的大小、起始地址、状态（是否已分配）

![分区说明表](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E8%AF%B4%E6%98%8E%E8%A1%A8.png)

- **优点**：实现简单，**无外部碎片**
- **缺点**：当用户程序太大，最大的分区也无法满足时，此时不得不采用覆盖技术来解决，但是覆盖技术又会降低性能；会**产生内部碎片**，内存利用率低下

### 连续分配：动态分区分配

**动态分区分配**又称为**可变分区分配**。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态的建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。

![动态分区分配](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F.png)

但是动态分区我们首先需要解决几个问题：
1. 系统需要使用什么样的数据结构记录内存的使用情况？

    使用两种常用数据结构：**空闲分区表（对象数组）**和**空闲分区链（链表）**
    
    ![动态分区数据结构](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png)
  
2. 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？

    为了解决选择哪个分区进行内存分配，我们使用了集中动态分区分配算法，从空闲分区表（或者空闲分区链）中选出一个分区分配给该作业。有关动态分区分配算法的内容在后面有相关介绍

3. 如何进行分区的分配与回收操作？

    按照分配算法，对分区进行分配与合并，并且对相应的分区表项进行修改
    
动态分区没有**内部碎片**，但是**有外部碎片**；**内部碎片，指分配给某进程的内存区域中，如果有些部分没有用上**；**外部碎片，指内存中的某些空闲分区由于太小而难以利用**。可以用过**紧凑技术**，将各个进程的内存空间挪位，来解决外部碎片。（当然地址转换需要使用动态重定位）

### 非连续分配：分页存储

### 非连续分配：分段存储

### 非连续分配：段页式存储

### 动态分区分配算法

## 内存的存储保护
