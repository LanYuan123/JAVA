# 内存

程序的运行必须先放入到内存当中，但是代码究竟是如何放入到内存中的呢？内存又是如何分配的呢？内存是怎样保证进程之间不能访问对方内存空间的？程序是怎样获取数据在内存中的位置的？这些就是我们将要在内存这一章节将要研究的问题。

- 内存的地址转换
- 内存地址空间的扩展
- 内存的分配与回收
- 内存的存储保护

-----

## 内存的地址转换


-----

## 内存的地址空间扩展

### 覆盖技术

### 交换技术

### 虚拟内存技术

在传统存储管理方式中，有以下两个特性：

- **一次性**：作业必须一次性全部装入内存后才能开始运行。这就会造成两个问题：1. 作业很大时，不能全部装入内存，导致大作业无法运行；2. 当大量作业要求运行时，由于内存无法容纳所有作业，因此只能少量作业能够运行，导致多道程序并发度下降
- **驻留性**：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源

对于以上的两个问题，我们使用虚拟内存技术来解决：**基于局部性原理**，在程序装入时，**可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存**，就可以让程序开始执行。在程序执行过程中，当**所访问的信息不再内存中时，由操作系统负责将信息从外存调入内存**，然后继续执行程序。若内存空间不够，由操作系统将内存中暂时用不到的信息换出到外存。我们在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。

虚拟内存技术是在离散分配的内存管理方式的基础上实现的，它**和离散分配管理方式有两个最大的区别**：
1. 请求调页（请求调段）功能：访问的信息不在内存时，将信息从外存中调入内存
2. 页面置换（段置换）功能：如果内存空间不够，将内存中暂时用不到的

#### 请求分页

**请求分页管理方式是在基本分页管理方式基础上扩展从而实现的一种虚拟内存管理技术**，请求分页在基本分页的基础上多了两个功能：请求调页和页面置换。

 为了实现“请求调页”功能，操作系统需要知道每个页面是否已经调入内存；如果还没调入，那么也需要知道该页面在外存中存放的位置。为了实现“页面置换”，操作系统也需要通过某些指标来决定换出哪些页面；有哪些没有被修改过，就不需要在浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改过的信息。**为了实现以上的这些功能，我们需要修改的页表，添加更多的页表项来标注这些信息。**
 
![请求分页页表]()

为了实现请求调页，**除了修改页表还不够，我们还要引入缺页中断机构**。每当我们要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列，放回就绪队列。如果内存中**有空闲块**，则为进程**分配一个空闲块**，将所缺页面装入该块，并修改页表中的响应页表项。如果内存中**没有空闲块**，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其先写回外存。未修改的页面不用写回外存

请求分页管理相比于基本分页管理在在查询物理地址时多了三个步骤：
1. 在查询页表时进行请求调页的判断，判断页表是否在内存中
2. 如果页面不在内存中，进行页面置换
3. 修改请求页表中的页表项

![请求分页过程]()

#### 页面置换

当内存没有多余的空闲块分配给某一个进程时，操作系统需要将一些暂时用不到的信息换出到外存，将我们需要用到的信息换入到内存，但是操作系统遵循怎样的原则进行页面的置换呢？这就是页面置换算法解决的问题。一共有五种置换算法：
1. 最佳置换算法（OPT）
2. 先进先出置换算法（FIFO）
3. 最近最久未使用置换算法（LRU）
4. 简易型时钟置换算法（CLOCK）
5. 改进型时钟置换算法

![页面置换算法]()

##### 最佳置换算法（OPT）

算法思想：每次选择**淘汰的页面**将是**以后永不使用**，或者**在最长时间内不再被访问的页面**，这样可以保证最低的缺页率

实现方法：**最佳置换算法可以保证最低的缺页率**，但是实际上，只有在进程执行的过程中才能知道接下来会访问到是哪个页面。操作系统无法提前预判页面访问序列。因此，**最佳置换算法才是无法实现的**

##### 先进先出置换算法（FIFO）

算法思想：每次选择**淘汰的页面**是**最早进入内存的页面**

实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块

**Belady异常**：当为进程分配的物理块数增大时，缺页次数不增反减的异常现象

**只有FIFO算法会产生Belady异常**。另外，FIFO算法虽然**实现简单**，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，**算法性能差**

##### 最近最久未使用置换算法（LRU）

算法思想：每次**淘汰的页面**是**最近最久未使用的页面**

实现方法：在每个页面对应的页表项，用**访问字段记录该页面自上次访问以来所经历的时间t**。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面

最近最久未使用置换算法的**算法性能好**，是最接近OPT算法性能的，但是实现起来需要**专门的硬件支持**，**算法的开销过大**

##### 简易型时钟置换算法（CLOCK）

算法思想：每次**淘汰页面**是**最近的没有使用的页面**

实现方法：为每个页面的页表项设置一个**访问位**，再将内存中的页面都通过链接指针**链接成一个循环队列**。当某页面被访问的时候，其访问位设置为1.当需要淘汰一个页面上的时候，只需要检查循环队列中页表项的访问位，**如果是0，就选择将该页换出；如果是1.则将它置为0，暂不换出**，继续检查下一个页面，**若在第一轮扫描的所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描**（第二轮扫描中一定会有访问位为0的页面，依次该算法**最多会经过过两轮扫描**）

##### 改进型时钟置换算法

算法思想：简单的时间置换算法仅仅考虑到一个页面最近是否被访问过。事实上，如果淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。所以，我们除了考虑一个页面最近有没有被访问过，还应该考虑此页面是否被修改过。**在其他条件相同时，应优先淘汰没有修改过的页面**，避免I/O操作。这就是改进型的时钟置换算法的思想

实现方法：为每个页面的页表项设置一个**访问位**和**修改位**，再将内存中的页面都通过链接指针**链接成一个循环队列**。当某页面被访问的时候，其访问位设置为1，不然为0。当某页面被修改的时候，其修改为设置为1，否则为0。开始循环检查链表
- 第一轮：从当前位置开始扫描到第一个（0,0）的页面用于替换，本轮扫描不修改任何标志位                   第一优先级：**未访问且未修改的页面**
- 第二轮：若第一轮扫描失败，则查找第一个为（0,1）的页面用于替换，本轮将所有扫描过的页访问位设置为0     第二优先级：**未访问但是修改过的页面**
- 第三轮：若第二轮扫描失败，则查找第一个为（0,0）的页面用于替换，本轮扫描不修改任何标志位              第三优先级：**访问过但是未修改的页面**
- 第四轮：若第三轮扫描失败，则查找第一个为（0,1）的页面用于替换                                     第四优先级 ：**访问过且修改过的页面**

由以上可知，改进型的时钟置换算法选择一个页面淘汰最多会进行四轮扫描

![页面置换算法比较]()

#### 页面置换策略

在了解页面置换策略之前，我们需要先了解几个概念

- **驻留集**：指请求分页存储管理中给进程分配的物理块的集合
- **固定分配**：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，**驻留集大小不变**
- **可变分配**：操作系统为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增减。即，**驻留集的大小可变**
- **局部置换**：发生缺页时只能选**进程自己的物理块进行置换**
- **全局置换**：发生缺页时，可以选择**系统保留的物理块分配给缺页进程**，也可以将**别的进程持有的物理块置换到外存，再分配给缺页进程**

页面置换策略，即**两种分配制度**和**两种置换制度**的**结合**，但是在固定分配的情况下，是无法完成全局置换的，所以只有三种分配置换方案

![页面分配置换策略]()

固定分配局部置换：系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是：很难在刚开始就确定为每个进程分配多少个物理块才算合理。（采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的物理块数）

可变分配局部置换：刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定的页面换出外存

可变分配全局置换：

-----

## 内存的分配与回收

内存的地址分配有两种方式，一种是连续地址分配，一种是非连续地址分配。连续分配是指为用户分配的必须是一个连续的内存空间，而非连续的地址分配，地址空间可以是不连续，离散的

### 连续分配：单一连续分配

在这种地址分配方式中，内存分为**系统区**和**用户区**。系统区通常位于内存的低地址部分，用于存放操作系统的相关数据。用户区用于存放用户程序数据，**用户区中只能有一道用户程序**，用户程序独占整个用户区空间

![单一连续分配](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%8D%95%E4%B8%80%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D.png)

- **优点**：实现简单，**没有外部碎片**；可以采用覆盖技术扩充内存；不一定需要采取内存保护
- **缺点**：只能用于单用户、单任务的操作系统中；**有内部碎片**；存储器利用率极低

### 连续分配：固定分区分配

为了能在内存中装入多道程序，并且这些程序之间又不会相互干扰，我们**将整个用户空间划分为若干个固定大小的分区**，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式

固定分区分配：
- 分区大小相等
- 分区大小不等

![固定分区分配方式](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D.png)

**分区大小相等**：缺乏灵活性，但是有时却很适合用于用一台计算机控制多个相同对象的场合(比如钢铁厂有n个相同的炼钢炉，可以将内存分为n个大小相等的区域放n个炼钢炉控制程序)

**分区大小不等**：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分

对于固定分区分配，操作系统需要建立一个数据结构--分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常安分区大小来排列，每个表项包括对应分区的大小、起始地址、状态（是否已分配）

![分区说明表](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E8%AF%B4%E6%98%8E%E8%A1%A8.png)

- **优点**：实现简单，**无外部碎片**
- **缺点**：当用户程序太大，最大的分区也无法满足时，此时不得不采用覆盖技术来解决，但是覆盖技术又会降低性能；会**产生内部碎片**，内存利用率低下

### 连续分配：动态分区分配

**动态分区分配**又称为**可变分区分配**。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态的建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。

![动态分区分配](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F.png)

但是动态分区我们首先需要解决几个问题：
1. 系统需要使用什么样的数据结构记录内存的使用情况？

    使用两种常用数据结构：**空闲分区表（对象数组）**和**空闲分区链（链表）**
    
    ![动态分区数据结构](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png)
  
2. 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？

    为了解决选择哪个分区进行内存分配，我们使用了集中动态分区分配算法，从空闲分区表（或者空闲分区链）中选出一个分区分配给该作业。有关动态分区分配算法的内容在后面有相关介绍

3. 如何进行分区的分配与回收操作？

    按照分配算法，对分区进行分配与合并，并且对相应的分区表项进行修改
    
动态分区没有**内部碎片**，但是**有外部碎片**；**内部碎片，指分配给某进程的内存区域中，如果有些部分没有用上**；**外部碎片，指内存中的某些空闲分区由于太小而难以利用**。可以用过**紧凑技术**，将各个进程的内存空间挪位，来解决外部碎片。（当然地址转换需要使用动态重定位）

### 离散分配：分页存储

分页存储**将内存划分为一个个大小相等的分区**，每个分区就是一个“**页框**”（或者是内存块，物理块，页帧等等），**每个页框有一个编号，页框号从0开始**。**然后将进程的地址空间也划分为和页框大小相等的一个个区域，称为“页”或者“页面”**，当然进程的最后一个页面可能没有一个页框那么大，因此**如果页框太大，那么可能产生过大的内部碎片**

在使用分页存储的操作系统中，操作系统**以页框为基本单位为各个进程分配内存空间**。进程的每个页面分别放入一个个页框中，也就是说进程的**页面**和内存的**页框**是一一对应关系

进程的各个页面不必连续存放，也不必按先后顺序来，可以离散的放到各个页框中，但这也就出现了一个问题 ，我们要如何知道一个个的页面和哪些页框进行对应呢？逻辑地址到物理地址的转换如何进行呢？于是我们使用页表来解决这个问题

**页表**：操作系统借助进程的页表将逻辑地址转换为物理地址，通常在操作系统中会设置一个**页表寄存器**，存放**页表在内存中的起始地址F**和**页表长度M**，进程在未执行时，**页表的始址**和**页表长度**放在进程控制块（PCB）中，当进程被调度的时候，操作系统内核会将他们放到页表寄存器中

![页表](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E9%A1%B5%E8%A1%A8.png)

**地址转换**：将逻辑地址的二进制数分为两部分，**前一部分为“页号”**，**后一部分为“页内偏移量”**。当我们要查询物理地址时，先通过页表寄存器判断页号是否越界，如果没有业界，通过页表寄存器找到页表在内存中的位置，然后访问内存，查询页表，找到页号对应的页框号，再通过页框号加上页内偏移量得到物理地址，最后去访问得到的这个物理地址

![基本地址转换](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png)

**加入快表的地址转换**：在上面的地址转换中，每次要访问一个逻辑地址，都需要查询内存的页表，由于局部性原理，可能连续很多次查到的都是同一个页表项，既然如此，我们就引入快表来解决此问题，快表，又称为**联想寄存器**，是一种访问速度比内存快很多的高速缓冲存储器，用来**存放当前访问的若干页表项**，以加速地址变换的过程。于此对应，内存中的**页表常被称为慢表**，在引入快表之后，将会在访问页表寄存器之前，先查询想要查询的页表项是否被放入在快表当中，如果在快表当中，则无需查询页表寄存器，直接找到实际的物理地址

**时间局部性**：如果执行了程序中的某条指令，那么不久后这条指令很有可能被再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）

**空间局部性**：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）

![基于快表的地址转换](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%BF%AB%E8%A1%A8.png)

**两级页表**：单级存在两个问题，一是页表必须连续存放，因此页表很大的时候，需要占用很多个连续的页框，二是没有必要让整个页表常驻内存，因为进程在一段时间内只需要访问某几个特定的页面，仿照先前我们解决进程在内存中离散存放的办法，我们可以对**页表进行再分页**。我们**将长长的页表进行分组，使每个内存块刚好放入一个分组**。这就使得我们需要为离散分配的页表再建立一张页表，称为**页目录表**（或者称为外层页表，层页表，二层页表），在进行查找的时候，从PCB中读出页目录始址和长度，放入到页表寄存器中，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置，在根据二级页号查表，找到最终想访问的内存块号

![二级页表](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8.png)

### 离散分配：分段存储

分段存储将进程的地址空间，**按照程序自身的逻辑关系划分为若干个段**，每一段都有一个段名，每段从0开始编址，以段为单位进行分配，**每个段在内存中占据连续空间，但是各段之间可以不相邻**

程序被分为多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需要为每一个进程建立一张段表

![段表](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%AE%B5%E8%A1%A8.png)

### 离散分配：段页式存储

在上面的两种离散分配方式中：

- **页是信息的物理单位**，分页的主要目的是为了实现离散分配，提高内存的利用率。分页仅仅是系统管理上的需要，完全是系统行为，**对用户不可见**
- **段是信息的逻辑单位**，分段的主要目的是为了更好的满足用户的需求，一个段通常包含着一组属于一个逻辑模块的信息，**分段对用户是可见的**，用户编程时需要显示的给出段名
- 页的大小固定且由系统决定
- 段的长度不固定，决定于用户编写的程序
- **分页**的用户进程地址空间是**一维**的，程序员只需要给出一个记忆符即可表示一个地址
- **分段**的用户进程地址空间是**二维**的，程序员在表示一个地址时，既要给出段名，也要给出段内地址

分页和分段各有各的优缺点，我们可以将二者的优点进行结合，形成一种新的————段页式存储

![分页和分段的优缺点](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png)

段页式存储是将段式存储和页式存储的优点结合在一起，**使用段式分配对进程进行逻辑划分，使用页式分配对内存进行物理上的划分，在将进程划分的每一段进行分页，**在将这些页放入到内存的页框中。这样的划分方式，**既做到了段式管理的方便按照逻辑模块实现信息的共享和保护，也做到页式管理的不产生外部碎片，内存利用率高。**

![段页式存储](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8.png)

段页式管理的方式会使得我们需要两张表（一张段表和一张页表）来共同管理内存和进行地址转换：
1. 由逻辑地址得到段号、页号、页内偏移量
2. 段号与段表寄存器中的段地址比较，检查是否越界
3. 由段表始址、段号到对应段表项
4. 根据段表中记录的页表长度、检查页号是否越界
5. 由段表中的页表地址、页号得到查询页表、找到相应页表项
6. 由页面存放的内存块号、页内偏移量得到最终的物理地址
7. 访问目标单元

![基本段页分配](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%9F%BA%E6%9C%AC%E6%AE%B5%E9%A1%B5%E5%88%86%E9%85%8D.png)


### 动态分区分配算法

![动态分区算法](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95.png)

#### 首次适应算法

算法思想：将空闲分区表（空闲分区链）按照起始地址从低到高排列，从表头或链头开始查找，找到第一个能满足大小的空闲分区

#### 最佳适应算法

算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域，因此为了保证当大进程到来时能有大片连续空间，可以尽可能多的留下大片的空闲内存区，即优先使用更小的空闲区。空闲分区按容量大小递增链接。每次分配内存时顺序查找空闲分区链（或者空闲分区表），找到大小能满足要求的第一个空闲分区

#### 最坏适应算法

算法思想：为了解决最佳适应算法的问题--即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。将空闲分区按递减次序链接。每次分配内存时顺序查找空闲分区链（或者空闲分区表），找到大小能满足要求的第一个空闲分区

#### 邻近适应算法

算法思想：首次适应算法每次都从链头或表头开始查找，这可能会导致低地址部分出现很多小的空闲分区，而每次查找的时候都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。将空闲分区按起始地址递增的顺序排列（排列为一个循环链表），每次分配内存时从上次查找结束的位置开始查找空闲分区表（空闲分区链），找到第一个大小能满足的空闲分区

-----

## 内存的存储保护
