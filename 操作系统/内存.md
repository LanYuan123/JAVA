# 内存

程序的运行必须先放入到内存当中，但是代码究竟是如何放入到内存中的呢？内存又是如何分配的呢？内存是怎样保证进程之间不能访问对方内存空间的？程序是怎样获取数据在内存中的位置的？这些就是我们将要在内存这一章节将要研究的问题。

- 内存的地址转换
- 内存地址空间的扩展
- 内存的分配与回收
- 内存的存储保护

## 内存的地址转换

## 内存的地址空间扩展

## 内存的分配与回收

内存的地址分配有两种方式，一种是连续地址分配，一种是非连续地址分配。连续分配是指为用户分配的必须是一个连续的内存空间，而非连续的地址分配，地址空间可以是不连续，离散的

### 连续分配：单一连续分配

在这种地址分配方式中，内存分为**系统区**和**用户区**。系统区通常位于内存的低地址部分，用于存放操作系统的相关数据。用户区用于存放用户程序数据，**用户区中只能有一道用户程序**，用户程序独占整个用户区空间

![单一连续分配](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%8D%95%E4%B8%80%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D.png)

- **优点**：实现简单，**没有外部碎片**；可以采用覆盖技术扩充内存；不一定需要采取内存保护
- **缺点**：只能用于单用户、单任务的操作系统中；**有内部碎片**；存储器利用率极低

### 连续分配：固定分区分配

为了能在内存中装入多道程序，并且这些程序之间又不会相互干扰，我们**将整个用户空间划分为若干个固定大小的分区**，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式

固定分区分配：
- 分区大小相等
- 分区大小不等

![固定分区分配方式](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D.png)

**分区大小相等**：缺乏灵活性，但是有时却很适合用于用一台计算机控制多个相同对象的场合(比如钢铁厂有n个相同的炼钢炉，可以将内存分为n个大小相等的区域放n个炼钢炉控制程序)

**分区大小不等**：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分

对于固定分区分配，操作系统需要建立一个数据结构--分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常安分区大小来排列，每个表项包括对应分区的大小、起始地址、状态（是否已分配）

![分区说明表](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E8%AF%B4%E6%98%8E%E8%A1%A8.png)

- **优点**：实现简单，**无外部碎片**
- **缺点**：当用户程序太大，最大的分区也无法满足时，此时不得不采用覆盖技术来解决，但是覆盖技术又会降低性能；会**产生内部碎片**，内存利用率低下

### 连续分配：动态分区分配

**动态分区分配**又称为**可变分区分配**。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态的建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。

![动态分区分配](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F.png)

但是动态分区我们首先需要解决几个问题：
1. 系统需要使用什么样的数据结构记录内存的使用情况？

    使用两种常用数据结构：**空闲分区表（对象数组）**和**空闲分区链（链表）**
    
    ![动态分区数据结构](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png)
  
2. 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？

    为了解决选择哪个分区进行内存分配，我们使用了集中动态分区分配算法，从空闲分区表（或者空闲分区链）中选出一个分区分配给该作业。有关动态分区分配算法的内容在后面有相关介绍

3. 如何进行分区的分配与回收操作？

    按照分配算法，对分区进行分配与合并，并且对相应的分区表项进行修改
    
动态分区没有**内部碎片**，但是**有外部碎片**；**内部碎片，指分配给某进程的内存区域中，如果有些部分没有用上**；**外部碎片，指内存中的某些空闲分区由于太小而难以利用**。可以用过**紧凑技术**，将各个进程的内存空间挪位，来解决外部碎片。（当然地址转换需要使用动态重定位）

### 离散分配：分页存储

分页存储**将内存划分为一个个大小相等的分区**，每个分区就是一个“**页框**”（或者是内存块，物理块，页帧等等），**每个页框有一个编号，页框号从0开始**。**然后将进程的地址空间也划分为和页框大小相等的一个个区域，称为“页”或者“页面”**，当然进程的最后一个页面可能没有一个页框那么大，因此**如果页框太大，那么可能产生过大的内部碎片**

在使用分页存储的操作系统中，操作系统**以页框为基本单位为各个进程分配内存空间**。进程的每个页面分别放入一个个页框中，也就是说进程的**页面**和内存的**页框**是一一对应关系

进程的各个页面不必连续存放，也不必按先后顺序来，可以离散的放到各个页框中，但这也就出现了一个问题 ，我们要如何知道一个个的页面和哪些页框进行对应呢？逻辑地址到物理地址的转换如何进行呢？于是我们使用页表来解决这个问题

**页表**：操作系统借助进程的页表将逻辑地址转换为物理地址，通常在操作系统中会设置一个**页表寄存器**，存放**页表在内存中的起始地址F**和**页表长度M**，进程在未执行时，**页表的始址**和**页表长度**放在进程控制块（PCB）中，当进程被调度的时候，操作系统内核会将他们放到页表寄存器中

![页表](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E9%A1%B5%E8%A1%A8.png)

**地址转换**：将逻辑地址的二进制数分为两部分，**前一部分为“页号”**，**后一部分为“页内偏移量”**。当我们要查询物理地址时，先通过页表寄存器判断页号是否越界，如果没有业界，通过页表寄存器找到页表在内存中的位置，然后访问内存，查询页表，找到页号对应的页框号，再通过页框号加上页内偏移量得到物理地址，最后去访问得到的这个物理地址

![基本地址转换](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png)

**加入快表的地址转换**：在上面的地址转换中，每次要访问一个逻辑地址，都需要查询内存的页表，由于局部性原理，可能连续很多次查到的都是同一个页表项，既然如此，我们就引入快表来解决此问题，快表，又称为**联想寄存器**，是一种访问速度比内存快很多的高速缓冲存储器，用来**存放当前访问的若干页表项**，以加速地址变换的过程。于此对应，内存中的**页表常被称为慢表**，在引入快表之后，将会在访问页表寄存器之前，先查询想要查询的页表项是否被放入在快表当中，如果在快表当中，则无需查询页表寄存器，直接找到实际的物理地址

**时间局部性**：如果执行了程序中的某条指令，那么不久后这条指令很有可能被再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）

**空间局部性**：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）

![基于快表的地址转换](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%BF%AB%E8%A1%A8.png)

**两级页表**：单级存在两个问题，一是页表必须连续存放，因此页表很大的时候，需要占用很多个连续的页框，二是没有必要让整个页表常驻内存，因为进程在一段时间内只需要访问某几个特定的页面，仿照先前我们解决进程在内存中离散存放的办法，我们可以对**页表进行再分页**。我们**将长长的页表进行分组，使每个内存块刚好放入一个分组**。这就使得我们需要为离散分配的页表再建立一张页表，称为**页目录表**（或者称为外层页表，层页表，二层页表），在进行查找的时候，从PCB中读出页目录始址和长度，放入到页表寄存器中，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置，在根据二级页号查表，找到最终想访问的内存块号

![二级页表](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8.png)

### 离散分配：分段存储

### 离散分配：段页式存储

### 动态分区分配算法

![动态分区算法](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95.png)

#### 首次适应算法

算法思想：将空闲分区表（空闲分区链）按照起始地址从低到高排列，从表头或链头开始查找，找到第一个能满足大小的空闲分区

#### 最佳适应算法

算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域，因此为了保证当大进程到来时能有大片连续空间，可以尽可能多的留下大片的空闲内存区，即优先使用更小的空闲区。空闲分区按容量大小递增链接。每次分配内存时顺序查找空闲分区链（或者空闲分区表），找到大小能满足要求的第一个空闲分区

#### 最坏适应算法

算法思想：为了解决最佳适应算法的问题--即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。将空闲分区按递减次序链接。每次分配内存时顺序查找空闲分区链（或者空闲分区表），找到大小能满足要求的第一个空闲分区

#### 邻近适应算法

算法思想：首次适应算法每次都从链头或表头开始查找，这可能会导致低地址部分出现很多小的空闲分区，而每次查找的时候都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。将空闲分区按起始地址递增的顺序排列（排列为一个循环链表），每次分配内存时从上次查找结束的位置开始查找空闲分区表（空闲分区链），找到第一个大小能满足的空闲分区

## 内存的存储保护
