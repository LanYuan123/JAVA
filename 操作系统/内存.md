# 内存

程序的运行必须先放入到内存当中，但是代码究竟是如何放入到内存中的呢？内存又是如何分配的呢？内存是怎样保证进程之间不能访问对方内存空间的？程序是怎样获取数据在内存中的位置的？这些就是我们将要在内存这一章节将要研究的问题。

- 内存的地址转换
- 内存地址空间的扩展
- 内存的分配与回收
- 内存的存储保护

## 内存的地址转换

## 内存的地址空间扩展

## 内存的分配与回收

内存的地址分配有两种方式，一种是连续地址分配，一种是非连续地址分配。连续分配是指为用户分配的必须是一个连续的内存空间，而非连续的地址分配，地址空间可以是不连续，离散的

### 连续分配：单一连续分配

在这种地址分配方式中，内存分为**系统区**和**用户区**。系统区通常位于内存的低地址部分，用于存放操作系统的相关数据。用户区用于存放用户程序数据，**用户区中只能有一道用户程序**，用户程序独占整个用户区空间

![单一连续分配]()

- **优点**：实现简单，**没有外部碎片**；可以采用覆盖技术扩充内存；不一定需要采取内存保护
- **缺点**：只能用于单用户、单任务的操作系统中；**有内部碎片**；存储器利用率极低

### 连续分配：固定分区分配

为了能在内存中装入多道程序，并且这些程序之间又不会相互干扰，我们**将整个用户空间划分为若干个固定大小的分区**，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式

固定分区分配：
- 分区大小相等
- 分区大小不等

![固定分区分配方式]()

**分区大小相等**：缺乏灵活性，但是有时却很适合用于用一台计算机控制多个相同对象的场合(比如钢铁厂有n个相同的炼钢炉，可以将内存分为n个大小相等的区域放n个炼钢炉控制程序)

**分区大小不等**：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分

对于固定分区分配，操作系统需要建立一个数据结构--分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常安分区大小来排列，每个表项包括对应分区的大小、起始地址、状态（是否已分配）

![分区说明表]()

- **优点**：实现简单，**无外部碎片**
- **缺点**：当用户程序太大，最大的分区也无法满足时，此时不得不采用覆盖技术来解决，但是覆盖技术又会降低性能；会**产生内部碎片**，内存利用率低下

### 连续分配：动态分区分配

### 非连续分配：

### 非连续分配：

### 非连续分配：

## 内存的存储保护
