**目录**：
- [进程](#进程)
  * [:palm_tree:进程的定义、组成、组织方式、特征](#-palm-tree-----------------)
    + [进程的定义与组成](#进程的定义与组成)
    + [进程的管理](#进程的管理)
    + [进程的特征](#进程的特征)
  * [:palm_tree:进程的状态与转换](#-palm-tree-进程的状态与转换)
    + [进程的状态](#进程的状态)
    + [进程的转换](#进程的转换)
  * [:palm_tree:进程控制](#-palm-tree-进程控制)
  * [:palm_tree:进程通讯](#-palm-tree-进程通讯)
  * [:palm_tree:进程调度](#-palm-tree-进程调度)
    + [处理机调度的概念和层次](#处理机调度的概念和层次)
    + [进程调度的时机](#进程调度的时机)
    + [进程调度的切换](#进程调度的切换)
    + [进程调度的方式](#进程调度的方式)
    + [进程调度算法](#进程调度算法)
      - [FCFS（先到先进行）算法](#fcfs---------)
      - [SJF（）算法](#sjf--算法)
      - [HRRN（）算法](#hrrn----)
      - [时间片轮转算法](#时间片轮转算法)
      - [优先级调度算法](#优先级调度算法)
      - [多级反馈队列算法](#多级反馈队列算法)
      - [信号量机制](#信号量机制)
  * [:palm_tree:进程同步的与互斥](#-palm-tree-进程同步的与互斥)
    + [进程同步](#进程同步)
    + [进程互斥](#进程互斥)

# 进程

## :palm_tree:进程的定义、组成、管理、特征

### 进程的定义与组成

在学进程之前，我们首先要知道程序是什么，程序就是一串指令序列。在早期计算机中，只支持单道程序，程序被放入到内存中，然后运行，程序的代码放在程序段内，程序运行过程处理的数据放在数据段内，CPU在运行程序的时候，只需要到内存中取指令和数据即可，在引入了多道程序技术后，同一时刻可以有多道程序并发的运行，相应的内存当中也会有这些程序的数据，由于在这个阶段，内存当中要存放多个程序的数据，操作系统想要多个程序实现并发的执行，那么它需要找到这些程序代码存放的位置，和数据所在的位置，还有一些IO设备，系统资源是分配给不同程序的，这些信息是需要记录下来让操作系统知晓的，这样才能方便操作系统掌控全局。为了方便操作系统的管理，完成程序的并发执行，因此引入了进程、进程实体的概念

![进程的组成](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90.png)

操作系统在每个程序运行之前，都会为程序配置一个数据结构，称之为进程控制块（PCB），用来描述进程中的各种信息（比如程序代码存放位置、使用的IO设备、数据存放位置等），所以**程序段、数据段、PCB三个部分组成了进程实体（进程映像），程序段存放代码指令、数据段存放运行时产生和使用的数据、PCN存放管理进程的各种信息，一般情况下，我们简称进程实体为进程。PCB是进程中最重要的一部分，我们所谓创建进程，实质上就是创建进程实体中的PCB，而撤销进程，就是撤销进程实体中的PCB，而PCB就是进程存在的唯一标准**

![PCB](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/PCB.png)

进程从不同的角度可以有不同的定义：
- 进程程序的一次执行过程
- 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
- 进程是具有独立功能得到程序在数据集合上运行的过程，他是系统进行资源分配和调度的一个独立单位
- **进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位**

### 进程的管理

在操作系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来，而进程的组织分为两种方式：链接和索引

![进程的组织](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F.png)

链接组织：

![链接组织](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E9%93%BE%E6%8E%A5%E7%BB%84%E7%BB%87.png)

索引组织：

![索引组织](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87.png)

### 进程的特征

![进程的特征](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81.png)

## :palm_tree:进程的状态与转换

### 进程的状态

进程是程序的一次执行。在这个执行过程中，有的进程正在被CPU处理，有的又需要等待CPU服务，可见进程的状态是会有各种变化的，为了方便对各个进程进行管理，操作系统需要将进程合理地划分为几种状态

进程的五种状态：
- **创建态**：操作系统为该需要创建的进程分配所需的内存空间等资源，并为其创建、初始化PCB
- **运行态**：此时进程占有CPU，并且在CPU上运行，在单核处理机环境下，每一时刻最多只有一个进程处于运行态，在多核环境ixa可以同时有两个进程处于运行态
- **阻塞态**：此时进程因为等待某一时间而暂时不能运行，比如等待操作系统分配打印机、等待读磁盘操作的结果，CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将进程所需的资源分配到位才能得到CPU的服务
- **就绪态**：此时已经具有了除CPU以外所有运行条件，但是由于没有空闲CPU，所以暂时不能运行，进程已经拥有了除处理机以外的所有资源，一旦获得处理机，即可立刻进入运行态开始运行，用一句话总结即：**万事具备，只欠CPU**
- **终止态**：进程运行结束（或者因为bug导致进程无法继续执行下去，比如数组越界，空指针异常等），需要撤销进程，操作系统将分配给进程的资源回收，撤销PCB

### 进程的转换

既然我们为进程区别出了五种状态，那么我们就需要知道什么情况下进程会进行状态的转换呢？它又是怎么样转换呢？

![进程的转换](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png)

- 首先我们从进程的创建说起，当一个进程要被创建时，会创建、初始化PCB分配系统资源，进程此时位于创建态，当系统完成了创建进程的一系列工作之后，进程就进入了就绪态，此时会修改PCB相应的内容，并将进程放入就绪队列
- 当一个进程处于就绪态，就说明它已经拥有了除了处理机之外的所有资源，也就意味着它有机会被处理机调度，这时需要等待上个进程运行完毕，然后该进程获得CPU资源，此时进程修改PCB相应内容，进入运行态
- 此时进程有了所有要运行需要的资源，在于是得以运行，在运行过程中，如果进程运行的时间片到了，或者说处理机被优先级更高的进程抢占了，那么该进程会修改PCB相应内容并且回到就绪队列中，进入就绪态，等待再次被调度，但是如果进程在运行过程中需要申请某种系统资源，或者说要等待某个事件的发生，那么此时进程将会被阻塞，进程修改PCB相应内容进入阻塞态
- 当进程进入阻塞态之后，会等待申请的资源被分配，或者等待事件的发生，如果资源被分配或者事件发生，那么进程将会由阻塞态转入就绪态，修改PCB相应内容，并且进入到就绪队列之中
- 如果进程在运行态正常运行完毕，或者出现异常，那么将会进入终止态，进程撤销PCB，收回相应资源，被"杀死"

**注意：**
- 运行态-->阻塞态是一种进程自身做出的**主动行为**
- 阻塞态-->就绪态不是进程自身能够控制的，是一种**被动行为**
- 阻塞态是不能直接变为运行态的，也不能由就绪态直接转换为阻塞态（因为进入阻塞态时进程主动请求的，必然会在运行时才发出这种请求）

## :palm_tree:进程控制

我们知道了进程是有多种状态的，而且进程会在这些状态之间来回的转化的，那么操作系统是怎么控制进程在这些状态之间的转换的呢？这就是进程控制了。进程控制的主要功能时对系统中的所有进程实施有效的管理，它具有实现进程状态转换的功能

从进程状态转换中我们可以知道，如果进程要进行状态转换，都需要修改PCB中的内容，并且放到相应的对列中，那么此时有一种情况，我们将进程已经放入到相应的队列之中，但是我们还没来得及修改进程的PCB，这时PCB中的状态标志位和进程所处队列就不一致了，这样会导致系统错误，这种情况是非常危险的，为了解决这种情况，我们就使用**原语**来实现对进程的控制，**原语的特点就是执行期间不允许中断，只能一气呵成**

原语其实是采用关中断指令和开中断指令实现的

![原语](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%8E%9F%E8%AF%AD.png)

当原语相关的程序代码开始执行之前，会先执行一个关中断指令，在执行了这个指令之后，如果此时外部有一个中断信号传来，那么这个中断信号是会被忽略掉的，暂时不会被处理，这就保证了原语代码中的一系列处理不会被中断，只有在执行了开中断指令之后，接收到外部中断信号，才会转入到相应的中断处理程序，那么我们可以看到，通过关中断和开中断就可以实现原语这种保证了原子性的操作，保证了安全性

我们在以上过程中可以看到，关/开中断的权限非常大，必然是只允许在核心态下执行的特权指令

## :palm_tree:进程通讯

## :palm_tree:进程调度

### 处理机调度的概念和层次

### 进程调度的时机

### 进程调度的切换

### 进程调度的方式

### 进程调度算法

#### FCFS（先到先进行）算法

#### SJF（）算法

#### HRRN（）算法

#### 时间片轮转算法

#### 优先级调度算法

#### 多级反馈队列算法

#### 信号量机制

## :palm_tree:进程同步的与互斥

### 进程同步

### 进程互斥
