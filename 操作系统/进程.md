**目录**：
- [进程](#进程)
  * [:palm_tree:进程的定义、组成、组织方式、特征](#-palm-tree-----------------)
    + [进程的定义与组成](#进程的定义与组成)
    + [进程的管理](#进程的管理)
    + [进程的特征](#进程的特征)
  * [:palm_tree:进程的状态与转换](#-palm-tree-进程的状态与转换)
    + [进程的状态](#进程的状态)
    + [进程的转换](#进程的转换)
  * [:palm_tree:进程控制](#-palm-tree-进程控制)
  * [:palm_tree:进程通讯](#-palm-tree-进程通讯)
    + [共享存储](#共享存储)
    + [管道通信](#管道通信)
    + [消息传递](#消息传递)
  * [:palm_tree:进程调度](#-palm-tree-进程调度)
    + [处理机调度的概念和层次](#处理机调度的概念和层次)
    + [进程调度的时机](#进程调度的时机)
    + [进程调度的切换](#进程调度的切换)
    + [进程调度的方式](#进程调度的方式)
    + [进程调度算法](#进程调度算法)
      - [调度算法的评价指标](#调度算法的评价指标)
      - [FCFS（先到先进行）算法](#fcfs先到先进行算法)
      - [SJF（短作业优先）算法](#sjf短作业优先算法)
      - [HRRN（高响应比优先）算法](#hrrn高响应比优先算法)
      - [前三种算法的对比总结](#前三种算法的对比总结)
      - [时间片轮转算法](#时间片轮转算法)
      - [优先级调度算法](#优先级调度算法)
      - [多级反馈队列算法](#多级反馈队列算法)
      - [后三种算法的对比总结](#后三种算法的对比总结)
  * [:palm_tree:进程同步的与互斥](#-palm-tree-进程同步的与互斥)
    + [信号量机制](#信号量机制)
    + [进程同步](#进程同步)
    + [进程互斥](#进程互斥)

# 进程

写在以下文章之前，关于进程，我有一些粗浅的想法：

**关于进程，首先我们要知道进程是什么？他是怎么样定义的？它的具体组成有哪些？等等这些信息，这就是我们要学习的进程的定义、组成、组织方式、特征。而进程其实就是计算机上的一个一个的程序，既然是程序，那么进程肯定是被系统进行调用的，而我们现在使用的计算机都是多进程并发并行的运作的，所以不同的进程有的可能正在调用，有的可能在等待调用，不同的进程在现代计算机系统中有不同的状态，我们需要去了解到底进程有哪些状态，这些状态之间可以怎么相互转换，这就是我们要学习的进程的状态和转换。那么在进程状态的转换中，操作系统是通过怎么样的方式来控制进程状态的转换的呢？这就是要学习的进程的控制。在系统中，有的进程正在运行，又在在等待运行，有的被阻塞等待，那么操作系统怎样确定调用哪些进程在CPU上运行，哪些进程先暂时等待呢？这就是我们要学习的进程的调度。进程在并发执行的时候，由于异步和共享有可能造成许多的问题，为了解决这些问题，操作系统会怎么做？这就是我们要学习的进程的同步与互斥。进程既然是程序，那么程序和程序之间一定会有信息的交流，那么进程之间是怎么进行通讯的呢？这就是我们要学习的进程的通讯**

## :palm_tree:进程的定义、组成、管理、特征

### 进程的定义与组成

在学进程之前，我们首先要知道程序是什么，程序就是一串指令序列。在早期计算机中，只支持单道程序，程序被放入到内存中，然后运行，程序的代码放在程序段内，程序运行过程处理的数据放在数据段内，CPU在运行程序的时候，只需要到内存中取指令和数据即可，在引入了多道程序技术后，同一时刻可以有多道程序并发的运行，相应的内存当中也会有这些程序的数据，由于在这个阶段，内存当中要存放多个程序的数据，操作系统想要多个程序实现并发的执行，那么它需要找到这些程序代码存放的位置，和数据所在的位置，还有一些IO设备，系统资源是分配给不同程序的，这些信息是需要记录下来让操作系统知晓的，这样才能方便操作系统掌控全局。为了方便操作系统的管理，完成程序的并发执行，因此引入了进程、进程实体的概念

![进程的组成](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90.png)

操作系统在每个程序运行之前，都会为程序配置一个数据结构，称之为进程控制块（PCB），用来描述进程中的各种信息（比如程序代码存放位置、使用的IO设备、数据存放位置等），所以**程序段、数据段、PCB三个部分组成了进程实体（进程映像），程序段存放代码指令、数据段存放运行时产生和使用的数据、PCN存放管理进程的各种信息，一般情况下，我们简称进程实体为进程。PCB是进程中最重要的一部分，我们所谓创建进程，实质上就是创建进程实体中的PCB，而撤销进程，就是撤销进程实体中的PCB，而PCB就是进程存在的唯一标准**

![PCB](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/PCB.png)

进程从不同的角度可以有不同的定义：
- 进程程序的一次执行过程
- 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
- 进程是具有独立功能得到程序在数据集合上运行的过程，他是系统进行资源分配和调度的一个独立单位
- **进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位**

### 进程的管理

在操作系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来，而进程的组织分为两种方式：链接和索引

![进程的组织](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F.png)

链接组织：

![链接组织](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E9%93%BE%E6%8E%A5%E7%BB%84%E7%BB%87.png)

索引组织：

![索引组织](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87.png)

### 进程的特征

![进程的特征](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81.png)

## :palm_tree:进程的状态与转换

### 进程的状态

进程是程序的一次执行。在这个执行过程中，有的进程正在被CPU处理，有的又需要等待CPU服务，可见进程的状态是会有各种变化的，为了方便对各个进程进行管理，操作系统需要将进程合理地划分为几种状态

进程的五种状态：
- **创建态**：操作系统为该需要创建的进程分配所需的内存空间等资源，并为其创建、初始化PCB
- **运行态**：此时进程占有CPU，并且在CPU上运行，在单核处理机环境下，每一时刻最多只有一个进程处于运行态，在多核环境ixa可以同时有两个进程处于运行态
- **阻塞态**：此时进程因为等待某一时间而暂时不能运行，比如等待操作系统分配打印机、等待读磁盘操作的结果，CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将进程所需的资源分配到位才能得到CPU的服务
- **就绪态**：此时已经具有了除CPU以外所有运行条件，但是由于没有空闲CPU，所以暂时不能运行，进程已经拥有了除处理机以外的所有资源，一旦获得处理机，即可立刻进入运行态开始运行，用一句话总结即：**万事具备，只欠CPU**
- **终止态**：进程运行结束（或者因为bug导致进程无法继续执行下去，比如数组越界，空指针异常等），需要撤销进程，操作系统将分配给进程的资源回收，撤销PCB

### 进程的转换

既然我们为进程区别出了五种状态，那么我们就需要知道什么情况下进程会进行状态的转换呢？它又是怎么样转换呢？

![进程的转换](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png)

- 首先我们从进程的创建说起，当一个进程要被创建时，会创建、初始化PCB分配系统资源，进程此时位于创建态，当系统完成了创建进程的一系列工作之后，进程就进入了就绪态，此时会修改PCB相应的内容，并将进程放入就绪队列
- 当一个进程处于就绪态，就说明它已经拥有了除了处理机之外的所有资源，也就意味着它有机会被处理机调度，这时需要等待上个进程运行完毕，然后该进程获得CPU资源，此时进程修改PCB相应内容，进入运行态
- 此时进程有了所有要运行需要的资源，在于是得以运行，在运行过程中，如果进程运行的时间片到了，或者说处理机被优先级更高的进程抢占了，那么该进程会修改PCB相应内容并且回到就绪队列中，进入就绪态，等待再次被调度，但是如果进程在运行过程中需要申请某种系统资源，或者说要等待某个事件的发生，那么此时进程将会被阻塞，进程修改PCB相应内容进入阻塞态
- 当进程进入阻塞态之后，会等待申请的资源被分配，或者等待事件的发生，如果资源被分配或者事件发生，那么进程将会由阻塞态转入就绪态，修改PCB相应内容，并且进入到就绪队列之中
- 如果进程在运行态正常运行完毕，或者出现异常，那么将会进入终止态，进程撤销PCB，收回相应资源，被"杀死"

**注意：**
- 运行态-->阻塞态是一种进程自身做出的**主动行为**
- 阻塞态-->就绪态不是进程自身能够控制的，是一种**被动行为**
- 阻塞态是不能直接变为运行态的，也不能由就绪态直接转换为阻塞态（因为进入阻塞态时进程主动请求的，必然会在运行时才发出这种请求）

## :palm_tree:进程控制

我们知道了进程是有多种状态的，而且进程会在这些状态之间来回的转化的，那么操作系统是怎么控制进程在这些状态之间的转换的呢？这就是进程控制了。进程控制的主要功能时对系统中的所有进程实施有效的管理，它具有实现进程状态转换的功能

从进程状态转换中我们可以知道，如果进程要进行状态转换，都需要修改PCB中的内容，并且放到相应的对列中，那么此时有一种情况，我们将进程已经放入到相应的队列之中，但是我们还没来得及修改进程的PCB，这时PCB中的状态标志位和进程所处队列就不一致了，这样会导致系统错误，这种情况是非常危险的，为了解决这种情况，我们就使用**原语**来实现对进程的控制，**原语的特点就是执行期间不允许中断，只能一气呵成**

原语其实是采用关中断指令和开中断指令实现的

![原语](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%8E%9F%E8%AF%AD.png)

当原语相关的程序代码开始执行之前，会先执行一个关中断指令，在执行了这个指令之后，如果此时外部有一个中断信号传来，那么这个中断信号是会被忽略掉的，暂时不会被处理，这就保证了原语代码中的一系列处理不会被中断，只有在执行了开中断指令之后，接收到外部中断信号，才会转入到相应的中断处理程序，那么我们可以看到，通过关中断和开中断就可以实现原语这种保证了原子性的操作，保证了安全性

我们在以上过程中可以看到，关/开中断的权限非常大，必然是只允许在核心态下执行的特权指令

原语所做的其实就是三类事情：
1. 更新PCB中的一些信息（比如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）
  - 所有的进程控制原语一定都会修改进程状态标志
  - 剥夺当前运行进程的CPU使用权必然需要保存其运行环境
  - 某进程开始运行前必然要恢复其运行环境
2. 将PCB插入合适的队列
3. 分配/回收资源

## :palm_tree:进程通讯

我们都知道进程是操作系统分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立，而且为了保证系统安全，一个进程是不能直接访问另一个进程的地址空间的。

但是我们在平常使用软件的过程中，相互交换信息是必不可少的，比如我们在微信上从图库中选择一张照片发送给朋友，这里的微信进程获取了图片进程中的信息，所以为了保证这些进程之间信息交换的进行和进程间通讯的安全，操作系统就提供了一些方法来让进程之间能进行相互安全的通讯

操作系统提供三种通讯方式：

![进程通讯](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF.png)

### 共享存储

![共享存储](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8.png)

两个进程不能访问对方的地址空间，所以操作系统就给他们提供了共享空间，然后两个进程之间的通讯就可以通过共享空间来进行，**我们需要注意的是，两个进程对共享空间的访问是互斥的，当进程一写数据时，进程二是不能读数据的，反之也亦然。（而对共享空间的互斥访问是通过操作系统提供的同步互斥工具（如P、V操作）实现的）**

1. 基于数据结构的共享：比如共享空间中存放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级的通信方式
2. 基于存储区的共享：在内存中划出一块共享存储区，数据的形式、存放的位置等信息都是由进程协商决定，而不是操作系统，这种共享方式速度更快，是一种高级的通信方式

### 管道通信

"管道"是指用于连接读写进程的一个共享文件，又名pipe文件，其实就是在内存中开辟一个大小固定的缓冲区

![管道通信](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1.png)

**管道通信有以下几点需要注意**：
- 管道只能采取半双工通信，某一段时间内只能实现单向的传输，如果要实现双向同时通信，则需要设置两个管道
- 各进程需要互斥的访问管道
- 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走，当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞
- 如果没有写满，则不予许读，如果没读空，就不予许写
- 数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况

### 消息传递

进程间的数据交换以格式化的信息为单位，进程通过操作系统提供的"发送消息/接收消息"两个原语进行数据交换

![消息传递](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92.png)

消息传递分为两种方式：
1. 直接通讯方式：发送进程会通过发送原语发送给接收进程，然后这个消息就会被放到接收进程的消息缓冲队列的队尾，然后接收进程就会通过接收原语从队列中依次获取消息
2. 间接通讯方式：和直接通讯方式类似，只不过这些消息是先发送到中间实体（信箱）中，比如计网中的邮件系统

## :palm_tree:进程调度

当有一堆任务需要处理，但是由于资源有限，这些事情没法同时处理的时候，这就需要某种规则来决定处理这些任务的顺序，这就是调度所研究的问题

### 处理机调度的概念和层次

在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行

处理机调度有三个层次：
- 高级调度（作业调度）
- 中级调度（）
- 初级调度（）

#### 高级调度（作业调度）

由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序

高级调度（作业调度）就是按照一定的规则从外存上出狱后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它们获得竞争处理机的权利

**高级调度是外存和内存之间的调度**。每个作业之只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。由于作业结束后就直接撤销PCB就行了，**所以高级调度主要是指调入的问题**，因为只有调入的时机才需要操作系统来确定，但是调出的时机必然是作业运行结束才调出

#### 中级调度（内存调度）

引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存，**这么做的目的是为了提高内存利用率和系统吞吐量**

暂时调到外存等待的进程状态位挂起状态，值得注意的是，**PCB并不会一起调到外存，而是会常驻内存。**PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB保持对各个进程的监控、管理。被挂起的进程PCB会被放到挂起队列中

**中级调度（内存调度），就是决定将哪个出狱挂起状态的进程重新调入内存。**一个进程可能会被多次调出、调入内存，所以中级调度发生的频率比高级调度更高

#### 低级调度（进程调度）

低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它

进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度，进程调度的频率很高，一般几十毫秒一次

#### 三层调度的联系、对比

![三层调度](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E4%B8%89%E5%B1%82%E8%B0%83%E5%BA%A6.png)

### 进程调度的时机

进程调度，就是按照某种算法从就绪队列中选择一个进程为其分配处理机

那么什么时候需要进行进程的调度呢？

需要进行进程调度与切换的情况
- 当前运行的进程主动放弃处理机
  - 进程正常终止
  - 运行过程发生异常终止
  - 进程主动请求阻塞（比如等待I/O）
- 当前运行的进程被动放弃处理机
  - 分给进程的时间片用完
  - 有优先级更高的事需要处理（比如I/O中断）
  - 有更高优先级的进程进入就绪队列

![进程调度的时机](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%88%87%E6%8D%A2.png)

不能进行进程调度与切换情况：
- 在处理中断的过程中，中断处理过程复杂，与硬件息息相关，很难在中断的处理过程中进行进程的切换
- 进程在操作系统内核程序临界区中
- 在原子操作过程中（原语），原子操作不可中断，一气呵成

![进程不能调度的时机](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E4%B8%8D%E8%83%BD%E5%88%87%E6%8D%A2.png)

### 进程调度的切换

**进程调度**和**进程切换**的区别：

**狭义的进程调度**指的是从就绪队列中**选中一个要运行的进程**
**进程切换**是指**一个进程让出处理机，由另一个进程占用处理机的过程**
**广义的进程调度**则是**包含了狭义的进程调度和进程切换的过程**

进程切换的过程完成了：
- 对原来运行进程环境的保存
- 对新进程运行环境的恢复

我们需要注意的是：</br>
**进程切换是有代价的**，因此如果过于**频繁的进行进程的调度、切换**，必然会使**整个系统的效率降低**，使系统大部分时间花在了进程切换上，而真正用于执行进程的时间减少

### 进程调度的方式

两种方式：
- 非剥夺调度方式，又称为非抢占方式。只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态
  - 优点：实现简单，系统开销小
  - 缺点：无法及时处理紧急任务，适用于早期的批处理系统
- 剥夺调度方式，又称抢占式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的进程
  - 可以优先处理更紧急的进程，也可以实现让进程按时间片轮流执行的功能（通过时钟中断）。适用于分时操作系统、实时操作系统

### 进程调度算法

进程在进行调度的时候，我们需要按照一定的规则来，也就是进程调度的算法，而我们在观察一个进程调度算法的时候，主要看以下方面：
- 算法思想
- 算法规则
- 此算法用于 作业调度 还是 进程调度
- 算法是 抢占式 还是 非抢占式
- 算法的 优点 和 缺点
- 算法是否会导致饥饿

在下文的几种调度算法的介绍中，就是围绕着以上几个方面来讲述的

#### 调度算法的评价指标

调度算法的评价指标有以下几样：

- **CPU利用率**：指CPU工作的时间占中时间的比例
  1. 公式：**CPU利用率 = 工作的时间/总时间**
- **系统吞吐量**：但是时间内完成作业的数量
  1. 公式：**系统吞吐量= 总共完成了多少道作业/总共花了多少时间**
- **周转时间**：指作业被提交到系统开始，到作业完成为止的这段时间间隔 ，包括4个部分：作业在外存后备队列上等待作业调度的时间、进程在就绪队列上等待进程调度的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间
  1. 公式：**周转时间 = 作业完成时间 - 作业提交时间**
- **平均周转时间**：所有作业周转时间的平均值
  1. 公式：**平均周转时间 = 各作业周转时间之和/作业数**
- **带权周转时间**
  1. 公式：**带权周转时间 = 作业周转时间/作业实际运行的时间**
  2. 带权周转时间必然>=1
  3. 带权周转时间与周转时间都是越小越好
- **平均带权周转时间**
  1. 公式：**平均带权周转时间 = 各作业带权周转时间之和/作业数**
- **等待时间**：指进程/作业处于等待处理机状态时间之和
  1. 对于进程，等待IO完成期间其实进程也是在被服务，所以不计入等待时间
  2. 对于作业，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间
- **响应时间**：指从用户提交请求到首次产生响应所用的时间

#### FCFS（先到先进行）算法

- 算法思想：主要从公平的角度考虑，先到来的进程先被调度，后来的进程后被调度，按先来后到的顺序调度（类似生活中排队买东西的例子）
- 算法规则：**按照作业/进程到达的先后顺序进行服务**
- 用于作业/进程：用于作业调度的额时候，考虑的是哪个作业先到达后备队列；用于进程调度的时候，考虑的是哪个进程先到达就绪队列
- 是否可抢占：**非抢占式**的算法
- 优点：**公平，算法实现简单**
- 缺点：排在长作业后面的短作业需要等待很长时间，带权周转时间很长，对短作业来说用户的体验十分不好，**即FCFS算法对长作业有力，对短作业不利**
- 是否会导致饥饿：不会，只要前面的进程能执行完 ，就一定能执行到本进程，所以不会导致饥饿

![FCFS](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/FCFS.png)

#### SJF（短作业优先）算法

- 算法思想：**追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间**
- 算法规则：**最短的作业/进程**可以**优先得到服务**（所谓最短，即是服务时间最短）
- 用于作业/进程：既可用于作业调度，也可以用于进程调度，用于进程调度时称为“短进程优先算法”
- 是否可抢占：非抢占式算法，但是也有抢占式的版本——最短剩余时间优先算法
- 优点：最短的平均等待时间、平均周转时间
- 缺点：不公平，对短作业有利、对长作业不利。可能会有饥饿现象的产生，还有另外很重要的一点，运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先
- 是否会导致饥饿：可能会，当一个进程的需要运行的时间很长，而且有源源不断的短进程进入时，长进程会饥饿

![SJF](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/SJF.png)

#### HRRN（高响应比优先）算法

在上面的两种算法当中：
- FCFS算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务，但是没有考虑到作业的运行时间，因此**导致了对短作业不友好的问题**
- SJF算法是选择一个执行时间最短的作业为其服务，但是又完全不考虑各个作业的等待时间，因此**导致了对长作业不友好的问题，甚至还会造成饥饿问题**

为了中和一下上面两种算法所带来的问题，人们设计出了HRRN算法，在考虑到各个作业的等待时间的同时，也能兼顾运行时间

- 算法思想：**综合考虑作业/进程的等待时间和要求服务的时间**
- 算法规则：在每次调度时**先计算各个作业/进程的响应比**，选择响应比最高的作业/进程先为其服务，**响应比 = （等待时间+服务时间）/服务时间**
- 用于作业/进程：既可用于作业调度，也可以用于进程调度
- 是否可抢占：**非抢占式算法**，因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比
- 优点：综合考虑了等待时间和运行时间，**在等待时间相同时，让需要服务时间短的进程优先（FCFS的优点）；在需要服务时间相同时，让等待时间长的优先（SJF的优点）**
- 是否会导致饥饿：不会，对长作业来说，等待时间越长，其响应比也就越大，避免了长作业饥饿的问题

![HRRN](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/HRRN.png)

#### 前三种算法的对比总结

以上的三种算法主要关心的是：**用户的公平性、平均周转时间、平均等待时间等**评价**系统整体性能的指标**，但是并**不关心“响应时间”**，也**不区分任务的紧急程度**，因此对于用户来说，**交互性能很糟糕**，因此这三种算法一般用于**早期的批处理系统**，而适用于交互式系统的调度算法，将是以下我们将介绍的三种算法

![三种算法比较总结](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E4%B8%89%E7%A7%8D%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.png)

#### 时间片轮转算法

- 算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应
- 算法规则：**按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片**。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队
- 用于作业/进程：**用于进程调度**（只有作业放入内存建立了相应的进程之后，才会被分配处理机时间片）
- 是否可抢占：若进程未能在时间片内运转完，将被强行剥夺处理机使用权，因此**时间片轮转算法属于抢占式的算法**。由时钟装置发出时钟中断来通知CPU时间已到
- 优点：**公平，响应快，更加适用于分时操作系统，更加注重“响应时间”**
- 缺点：由于**高频率的进程切换，因此有一定的开销，而且该算法不会区分任务的紧急程度**
- 是否会导致饥饿：不会

![时间片轮转算法](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E7%AE%97%E6%B3%95.png)

该算法是通过给每个进程分配时间片来对进程进行调度的，那么时间片大小的设置就成为了关键：
- 如果时间片太大，使得每个进程都可以在一个时间片内完成，**则时间轮转算法就退化为先来先服务算法**，并且会增大进程响应时间，因此时间片不能太大
- 如果时间片太小，会导致进程切换过于频繁，由于进程切换是有时间代价，会消耗系统资源的，所以系统会花费大量时间来处理进程切换，从而对导致实际用于进程执行的时间比例减少，可见时间片也不能太小

#### 优先级调度算法

- 算法思想：随着计算机的发展，特别是实时操作系统的出现，**越来越多的应用场景需要根据任务的紧急程度来决定处理顺序**
- 算法规则：每个作业/进程有各自的优先级，**调度时选择优先级最高的的作业/进程**
- 用于作业/进程：既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/O调度中
- 是否可抢占：**抢占式、非抢占式都有**
- 优点：**用优先级区分紧急度、重要程度，适用于实时操作系统**。可灵活地调整对各种作业/进程的偏好程度
- 缺点：若源源不断的有高优先级进程到来，则**可能导致饥饿**
- 是否会导致饥饿：**如果有源源不断地高优先级到来，则会优先级低的进程一直得不到处理机，最后导致饥饿**

![优先级调度算法](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png)

该算法分为抢占式和非抢占式两个版本：
- 非抢占式版本：每次调度时选择当前已经**到达**且**优先级最高的**进程，当前进程主动放弃处理机时发生调度
- 抢占式版本：每次调度时选择**当前已到达**且**优先级最高**的进程进行调用，当前进程主动放弃处理机时发生调度。还有另外一种情况，就是当**就绪队列发生改变时**也会检查优先级，如果有优先级更高的进程，则会发生抢占

该算法也可以根据是否可以动态改变来进行划分，可以将优先级分为**静态优先级**和**动态优先级**两种
- 静态优先级：创建进程时确定，之后优先级一直不变
- 动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级

那么操作系统如何合理的设置各类进程的优先级呢？

通常：
- 系统进程优先级 高于 用户进程
- 前台进程优先级 高于 后台进程
- 操作系统更偏好I/O繁忙型进程 高于 CPU繁忙型进程（计算型进程）
- ......

如果采用的是动态优先级，什么时候进行调整比较合适呢？

- 如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级
- 如果某进程占用处理机运行了很长时间，则可适当降低其优先级
- 如果一个进程频繁进行I/O操作，则可适当提升其优先级
- ......

#### 多级反馈队列算法

在之前所有的算法中：
- FCFS的优点是公平，且对长作业友好
- SJF算法的优点是能尽快处理完短作业，对短作业友好，平均等待/周转时间等参数优秀
- 时间片轮转算法可以让各个进程得到及时的响应
- 优先级调度可以灵活的调整各种进程被服务的机会

每种算法都有各自的优缺点，那么现在能不能有一种算法对其他算法做个折中权衡？得到一个综合表现优秀平衡的算法呢？当然有，就是我们接下来要介绍的多级反馈队列算法

- 算法思想：对其他算法各自优缺点的折中权衡
- 算法规则：
  1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
  2. 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾，若此时已经是最下级的队列，则重新放回该队列队尾
  3. 只有第k级队列为空时，才会为k+1级队头的进程分配时间片
  4. ![队列图](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E9%98%9F%E5%88%97%E5%9B%BE.png)
- 用于作业/进程：用于进程调度
- 是否可抢占：**抢占式算法**，在k级队列的进程运行过程中，若更上级的队列中进入了一个新进程，则由于新进程的优先级更高，新进程会抢占处理机，原来运行的进程会被重新放回到k级队尾
- 优点：对各类型进程相对公平（FCFS的优点）；每个新到达的进程都可以很快得到响应（HRRN的优点）；短进程只用较少时间就可完成（SJF的优点）；不必估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（比如可以将因I/O阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级）
- 缺点：可能会导致饥饿
- 是否会导致饥饿：会

![多级反馈队列算法](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E7%AE%97%E6%B3%95.png)

#### 后三种算法的对比总结

比起早期的批处理系统来说，后期的计算机造价大幅度降低，因此之后出现的交互式操作系统（包括分时操作系统，实时操作系统等）更加注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求，因此这三种算法适合于交互式操作系统（比如说UNIX使用的就是多级反馈队列调度算法）

![三种算法的比较](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%90%8E%E4%B8%89%E7%A7%8D%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83.png)

## :palm_tree:进程同步的与互斥

### 进程同步

进程的同步是和进程异步息息相关的，各并发执行的进程以各自独立的、不可预知的速度向前推进。由于进程的并发必然会导致异步性，程序的执行顺序是不确定的，而我们在某些应用场景下必然会让程序按照一定的执行顺序执行，这就是进程同步所讨论的问题

**同步也称为直接制约关系**，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。

### 进程互斥

在了解进程互斥的概念之前，我们先来了解一下临界资源的概念，许多物理设备都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源

进程的并发需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源（比如内存，又比如打印机、摄像头这样的I/O设备），但是很多的系统资源是临界资源，对于临界资源的访问，必须互斥的进行。**互斥，也称为简介制约关系**。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待，当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源

对临界资源的互斥访问，可以在逻辑上分为如下四个部分：
![互斥的四个部分]()

- 进入区：**负责检查是否可以进入临界区**，如果可以进入，则应设置正在访问临界资源的标志（可以理解为“上锁”），以阻止其他进程同时进入临界区
- 临界区：**访问临界资源的那段代码**
- 退出区：**负责解除正在访问临界资源的标志**
- 剩余区：**做其他处理**
- 注意：**进入区和退出去是实现互斥的代码段**

为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下四个原则：
- **空闲让进**：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区
- **忙则等待**：当已有进程进入临界区时，其他试图进入临界区的进程必须等待
- **有限等待**：对请求访问的进程，应该能保证在有限时间内进入临界区（即保证不会饥饿）
- **让权等待**：当进程不能进入临界区时，应该立即释放处理机，防止进程忙等待

#### 进程互斥的软件实现方法

实现进程互斥的软件实现方法一共有4种：
- 单标志法
- 双标志先检查法
- 双标志后检查法
- Peterson算法

以下我们将对各个算法进行理解，在理解算法的过程中我们主要应从以下几方面来理解算法：
1. 理解算法的思想、原理
2. 结合上小节学习的“实现互斥的四个逻辑部分”，重点理解各算法在进入区、退出区都做了什么
3. 结合实现互斥遵循的四个原则，分析各算法存在的缺陷

##### 单标志法

算法思想：一个进程在**访问完临界区后**会把使用临界区的权限转交给另一个进程。也就是说**每个进程进入临界区的权限只能被另一个进程赋予**

![单标志法]()

变量turn存储的是当前允许进入临界区的进程号。turn的初始值0，是P0的进程号，只有P0可以进入临界区，若P1先上处理机运行，则会一直卡在代码5上。直至P1的时间片用完，发生调度，切换P0上处理机运行。代码1不会卡住P0，P0可以正常访问临界区，在P0访问临界区期间及时切换回P1，P1依然会卡在代码5。只有P0在退出区将turn改为1后，P1才能进入临界区

问题：这种算法带来的问题也很明显，**如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然临界区是空闲的，但是并不会允许其他进程访问**，因此此算法存在的主要问题是：**违背了空闲让进原则**

##### 双标志先检查法

算法思想：设置一个布尔型数组flag[],数组中各个元素用来**标记各进程想进入临界区的意愿**，比如“flag[0] = true”意味着0号进程P0现在想要进入临界区。每个进程在进临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设置为true，之后开始访问临界区

![双标志先检查法]()

问题：由于进程的异步性，如果按照代码152637的顺序来执行，P0和P1将会同时访问临界区。因此，双标志先检查法的主要问题是：**违反了忙则等待的原则**，**原因在于，进入区的"检查"和"上锁"两个处理不是一气呵成的。"检查"后，"上锁"前可能发生进程切换**

##### 双标志后检查法

算法思想：双标志先检查法的改变。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此人们又想到了先“上锁”后“检查”的方法来避免上述问题

![双标志后检查法]()

问题：改变了“检查”和“上锁”的顺序之后，虽然没了双标志先检查法的问题，但是又有了新的问题。由于进程的异步性，**如果按照1526的顺序来执行，P0和P1都无法进入临界区，因此会因各进程都长期无法访问临界资源而产生“饥饿现象”，两个进程争着进入临界区，但是谁也不让谁，最后谁都无法进入临界区**

##### Peterson算法

算法思想：在双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。于是Peterson想到一种方法，如果双方都争着向进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区

![Peterson算法]()

该算法使用两种标志，一种是flag数组，一种是turn变量。flag数组表示有进入临界区进程的数组，turn表示优先让哪个进程进入临界区，每个进程在首先设置代表自己的flag[i]为true（表达自己想进入临界区的意愿），然后设置trun的值（表示愿意优先让哪个进程进入临界区），接下来while循环体里面将会检查别的进程是否想要使用临界区还有优先进程是谁，根据检查结果判断是否进入临界区，使用临界资源

问题：Peterson算法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是**依然无法满足让权等待原则**，相比于之前的三种算法，Peterson算法是最好的，但是还不够好，后面我们将介绍信号量机制来解决问题

#### 进程互斥的硬件实现方法


### 信号量机制
