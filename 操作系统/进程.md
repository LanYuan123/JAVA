**目录**：
- [进程](#进程)
  * [:palm_tree:进程的定义、组成、组织方式、特征](#-palm-tree-----------------)
    + [进程的定义与组成](#进程的定义与组成)
    + [进程的管理](#进程的管理)
    + [进程的特征](#进程的特征)
  * [:palm_tree:进程的状态与转换](#-palm-tree-进程的状态与转换)
    + [进程的状态](#进程的状态)
    + [进程的转换](#进程的转换)
  * [:palm_tree:进程控制](#-palm-tree-进程控制)
  * [:palm_tree:进程通讯](#-palm-tree-进程通讯)
    + [共享存储](#共享存储)
    + [管道通讯](#管道通讯)
    + [消息传递](#消息传递)
  * [:palm_tree:进程调度](#-palm-tree-进程调度)
    + [处理机调度的概念和层次](#处理机调度的概念和层次)
    + [进程调度的时机](#进程调度的时机)
    + [进程调度的切换](#进程调度的切换)
    + [进程调度的方式](#进程调度的方式)
    + [进程调度算法](#进程调度算法)
      - [FCFS（先到先进行）算法](#fcfs---------)
      - [SJF（）算法](#sjf--算法)
      - [HRRN（）算法](#hrrn----)
      - [时间片轮转算法](#时间片轮转算法)
      - [优先级调度算法](#优先级调度算法)
      - [多级反馈队列算法](#多级反馈队列算法)
      - [信号量机制](#信号量机制)
  * [:palm_tree:进程同步的与互斥](#-palm-tree-进程同步的与互斥)
    + [进程同步](#进程同步)
    + [进程互斥](#进程互斥)

# 进程

## :palm_tree:进程的定义、组成、管理、特征

### 进程的定义与组成

在学进程之前，我们首先要知道程序是什么，程序就是一串指令序列。在早期计算机中，只支持单道程序，程序被放入到内存中，然后运行，程序的代码放在程序段内，程序运行过程处理的数据放在数据段内，CPU在运行程序的时候，只需要到内存中取指令和数据即可，在引入了多道程序技术后，同一时刻可以有多道程序并发的运行，相应的内存当中也会有这些程序的数据，由于在这个阶段，内存当中要存放多个程序的数据，操作系统想要多个程序实现并发的执行，那么它需要找到这些程序代码存放的位置，和数据所在的位置，还有一些IO设备，系统资源是分配给不同程序的，这些信息是需要记录下来让操作系统知晓的，这样才能方便操作系统掌控全局。为了方便操作系统的管理，完成程序的并发执行，因此引入了进程、进程实体的概念

![进程的组成](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90.png)

操作系统在每个程序运行之前，都会为程序配置一个数据结构，称之为进程控制块（PCB），用来描述进程中的各种信息（比如程序代码存放位置、使用的IO设备、数据存放位置等），所以**程序段、数据段、PCB三个部分组成了进程实体（进程映像），程序段存放代码指令、数据段存放运行时产生和使用的数据、PCN存放管理进程的各种信息，一般情况下，我们简称进程实体为进程。PCB是进程中最重要的一部分，我们所谓创建进程，实质上就是创建进程实体中的PCB，而撤销进程，就是撤销进程实体中的PCB，而PCB就是进程存在的唯一标准**

![PCB](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/PCB.png)

进程从不同的角度可以有不同的定义：
- 进程程序的一次执行过程
- 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
- 进程是具有独立功能得到程序在数据集合上运行的过程，他是系统进行资源分配和调度的一个独立单位
- **进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位**

### 进程的管理

在操作系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来，而进程的组织分为两种方式：链接和索引

![进程的组织](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F.png)

链接组织：

![链接组织](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E9%93%BE%E6%8E%A5%E7%BB%84%E7%BB%87.png)

索引组织：

![索引组织](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87.png)

### 进程的特征

![进程的特征](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81.png)

## :palm_tree:进程的状态与转换

### 进程的状态

进程是程序的一次执行。在这个执行过程中，有的进程正在被CPU处理，有的又需要等待CPU服务，可见进程的状态是会有各种变化的，为了方便对各个进程进行管理，操作系统需要将进程合理地划分为几种状态

进程的五种状态：
- **创建态**：操作系统为该需要创建的进程分配所需的内存空间等资源，并为其创建、初始化PCB
- **运行态**：此时进程占有CPU，并且在CPU上运行，在单核处理机环境下，每一时刻最多只有一个进程处于运行态，在多核环境ixa可以同时有两个进程处于运行态
- **阻塞态**：此时进程因为等待某一时间而暂时不能运行，比如等待操作系统分配打印机、等待读磁盘操作的结果，CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将进程所需的资源分配到位才能得到CPU的服务
- **就绪态**：此时已经具有了除CPU以外所有运行条件，但是由于没有空闲CPU，所以暂时不能运行，进程已经拥有了除处理机以外的所有资源，一旦获得处理机，即可立刻进入运行态开始运行，用一句话总结即：**万事具备，只欠CPU**
- **终止态**：进程运行结束（或者因为bug导致进程无法继续执行下去，比如数组越界，空指针异常等），需要撤销进程，操作系统将分配给进程的资源回收，撤销PCB

### 进程的转换

既然我们为进程区别出了五种状态，那么我们就需要知道什么情况下进程会进行状态的转换呢？它又是怎么样转换呢？

![进程的转换](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png)

- 首先我们从进程的创建说起，当一个进程要被创建时，会创建、初始化PCB分配系统资源，进程此时位于创建态，当系统完成了创建进程的一系列工作之后，进程就进入了就绪态，此时会修改PCB相应的内容，并将进程放入就绪队列
- 当一个进程处于就绪态，就说明它已经拥有了除了处理机之外的所有资源，也就意味着它有机会被处理机调度，这时需要等待上个进程运行完毕，然后该进程获得CPU资源，此时进程修改PCB相应内容，进入运行态
- 此时进程有了所有要运行需要的资源，在于是得以运行，在运行过程中，如果进程运行的时间片到了，或者说处理机被优先级更高的进程抢占了，那么该进程会修改PCB相应内容并且回到就绪队列中，进入就绪态，等待再次被调度，但是如果进程在运行过程中需要申请某种系统资源，或者说要等待某个事件的发生，那么此时进程将会被阻塞，进程修改PCB相应内容进入阻塞态
- 当进程进入阻塞态之后，会等待申请的资源被分配，或者等待事件的发生，如果资源被分配或者事件发生，那么进程将会由阻塞态转入就绪态，修改PCB相应内容，并且进入到就绪队列之中
- 如果进程在运行态正常运行完毕，或者出现异常，那么将会进入终止态，进程撤销PCB，收回相应资源，被"杀死"

**注意：**
- 运行态-->阻塞态是一种进程自身做出的**主动行为**
- 阻塞态-->就绪态不是进程自身能够控制的，是一种**被动行为**
- 阻塞态是不能直接变为运行态的，也不能由就绪态直接转换为阻塞态（因为进入阻塞态时进程主动请求的，必然会在运行时才发出这种请求）

## :palm_tree:进程控制

我们知道了进程是有多种状态的，而且进程会在这些状态之间来回的转化的，那么操作系统是怎么控制进程在这些状态之间的转换的呢？这就是进程控制了。进程控制的主要功能时对系统中的所有进程实施有效的管理，它具有实现进程状态转换的功能

从进程状态转换中我们可以知道，如果进程要进行状态转换，都需要修改PCB中的内容，并且放到相应的对列中，那么此时有一种情况，我们将进程已经放入到相应的队列之中，但是我们还没来得及修改进程的PCB，这时PCB中的状态标志位和进程所处队列就不一致了，这样会导致系统错误，这种情况是非常危险的，为了解决这种情况，我们就使用**原语**来实现对进程的控制，**原语的特点就是执行期间不允许中断，只能一气呵成**

原语其实是采用关中断指令和开中断指令实现的

![原语](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%8E%9F%E8%AF%AD.png)

当原语相关的程序代码开始执行之前，会先执行一个关中断指令，在执行了这个指令之后，如果此时外部有一个中断信号传来，那么这个中断信号是会被忽略掉的，暂时不会被处理，这就保证了原语代码中的一系列处理不会被中断，只有在执行了开中断指令之后，接收到外部中断信号，才会转入到相应的中断处理程序，那么我们可以看到，通过关中断和开中断就可以实现原语这种保证了原子性的操作，保证了安全性

我们在以上过程中可以看到，关/开中断的权限非常大，必然是只允许在核心态下执行的特权指令

原语所做的其实就是三类事情：
1. 更新PCB中的一些信息（比如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）
  - 所有的进程控制原语一定都会修改进程状态标志
  - 剥夺当前运行进程的CPU使用权必然需要保存其运行环境
  - 某进程开始运行前必然要恢复其运行环境
2. 将PCB插入合适的队列
3. 分配/回收资源

## :palm_tree:进程通讯

我们都知道进程是操作系统分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立，而且为了保证系统安全，一个进程是不能直接访问另一个进程的地址空间的。

但是我们在平常使用软件的过程中，相互交换信息是必不可少的，比如我们在微信上从图库中选择一张照片发送给朋友，这里的微信进程获取了图片进程中的信息，所以为了保证这些进程之间信息交换的进行和进程间通讯的安全，操作系统就提供了一些方法来让进程之间能进行相互安全的通讯

操作系统提供三种通讯方式：

![进程通讯](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF.png)

### 共享存储

![共享存储](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8.png)

两个进程不能访问对方的地址空间，所以操作系统就给他们提供了共享空间，然后两个进程之间的通讯就可以通过共享空间来进行，**我们需要注意的是，两个进程对共享空间的访问是互斥的，当进程一写数据时，进程二是不能读数据的，反之也亦然。（而对共享空间的互斥访问是通过操作系统提供的同步互斥工具（如P、V操作）实现的）**

1. 基于数据结构的共享：比如共享空间中存放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级的通信方式
2. 基于存储区的共享：在内存中划出一块共享存储区，数据的形式、存放的位置等信息都是由进程协商决定，而不是操作系统，这种共享方式速度更快，是一种高级的通信方式

### 管道通信

"管道"是指用于连接读写进程的一个共享文件，又名pipe文件，其实就是在内存中开辟一个大小固定的缓冲区

![管道通信](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1.png)

**管道通信有以下几点需要注意**：
- 管道只能采取半双工通信，某一段时间内只能实现单向的传输，如果要实现双向同时通信，则需要设置两个管道
- 各进程需要互斥的访问管道
- 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走，当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞
- 如果没有写满，则不予许读，如果没读空，就不予许写
- 数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况

### 消息传递

进程间的数据交换以格式化的信息为单位，进程通过操作系统提供的"发送消息/接收消息"两个原语进行数据交换

![消息传递](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92.png)

消息传递分为两种方式：
1. 直接通讯方式：发送进程会通过发送原语发送给接收进程，然后这个消息就会被放到接收进程的消息缓冲队列的队尾，然后接收进程就会通过接收原语从队列中依次获取消息
2. 间接通讯方式：和直接通讯方式类似，只不过这些消息是先发送到中间实体（信箱）中，比如计网中的邮件系统

## :palm_tree:进程调度

### 处理机调度的概念和层次

### 进程调度的时机

### 进程调度的切换

### 进程调度的方式

### 进程调度算法

#### FCFS（先到先进行）算法

#### SJF（）算法

#### HRRN（）算法

#### 时间片轮转算法

#### 优先级调度算法

#### 多级反馈队列算法

#### 信号量机制

## :palm_tree:进程同步的与互斥

### 进程同步

### 进程互斥
