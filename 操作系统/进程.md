**目录**：
- [进程](#进程)
  * [:palm_tree:进程的定义、组成、组织方式、特征](#-palm-tree-----------------)
    + [进程的定义与组成](#进程的定义与组成)
    + [进程的管理](#进程的管理)
    + [进程的特征](#进程的特征)
  * [:palm_tree:进程的状态与转换](#-palm-tree-进程的状态与转换)
    + [进程的状态](#进程的状态)
    + [进程的转换](#进程的转换)
  * [:palm_tree:进程控制](#-palm-tree-进程控制)
  * [:palm_tree:进程通讯](#-palm-tree-进程通讯)
    + [共享存储](#共享存储)
    + [管道通信](#管道通信)
    + [消息传递](#消息传递)
  * [:palm_tree:进程调度](#-palm-tree-进程调度)
    + [处理机调度的概念和层次](#处理机调度的概念和层次)
    + [进程调度的时机](#进程调度的时机)
    + [进程调度的切换](#进程调度的切换)
    + [进程调度的方式](#进程调度的方式)
    + [进程调度算法](#进程调度算法)
      - [调度算法的评价指标](#调度算法的评价指标)
      - [FCFS（先到先进行）算法](#fcfs先到先进行算法)
      - [SJF（短作业优先）算法](#sjf短作业优先算法)
      - [HRRN（高响应比优先）算法](#hrrn高响应比优先算法)
      - [三种算法的对比总结](#三种算法的对比总结)
      - [时间片轮转算法](#时间片轮转算法)
      - [优先级调度算法](#优先级调度算法)
      - [多级反馈队列算法](#多级反馈队列算法)
  * [:palm_tree:进程同步的与互斥](#-palm-tree-进程同步的与互斥)
    + [信号量机制](#信号量机制)
    + [进程同步](#进程同步)
    + [进程互斥](#进程互斥)

# 进程

写在以下文章之前，关于进程，我有一些粗浅的想法：

**关于进程，首先我们要知道进程是什么？他是怎么样定义的？它的具体组成有哪些？等等这些信息，这就是我们要学习的进程的定义、组成、组织方式、特征。而进程其实就是计算机上的一个一个的程序，既然是程序，那么进程肯定是被系统进行调用的，而我们现在使用的计算机都是多进程并发并行的运作的，所以不同的进程有的可能正在调用，有的可能在等待调用，不同的进程在现代计算机系统中有不同的状态，我们需要去了解到底进程有哪些状态，这些状态之间可以怎么相互转换，这就是我们要学习的进程的状态和转换。那么在进程状态的转换中，操作系统是通过怎么样的方式来控制进程状态的转换的呢？这就是要学习的进程的控制。在系统中，有的进程正在运行，又在在等待运行，有的被阻塞等待，那么操作系统怎样确定调用哪些进程在CPU上运行，哪些进程先暂时等待呢？这就是我们要学习的进程的调度。进程在并发执行的时候，由于异步和共享有可能造成许多的问题，为了解决这些问题，操作系统会怎么做？这就是我们要学习的进程的同步与互斥。进程既然是程序，那么程序和程序之间一定会有信息的交流，那么进程之间是怎么进行通讯的呢？这就是我们要学习的进程的通讯**

## :palm_tree:进程的定义、组成、管理、特征

### 进程的定义与组成

在学进程之前，我们首先要知道程序是什么，程序就是一串指令序列。在早期计算机中，只支持单道程序，程序被放入到内存中，然后运行，程序的代码放在程序段内，程序运行过程处理的数据放在数据段内，CPU在运行程序的时候，只需要到内存中取指令和数据即可，在引入了多道程序技术后，同一时刻可以有多道程序并发的运行，相应的内存当中也会有这些程序的数据，由于在这个阶段，内存当中要存放多个程序的数据，操作系统想要多个程序实现并发的执行，那么它需要找到这些程序代码存放的位置，和数据所在的位置，还有一些IO设备，系统资源是分配给不同程序的，这些信息是需要记录下来让操作系统知晓的，这样才能方便操作系统掌控全局。为了方便操作系统的管理，完成程序的并发执行，因此引入了进程、进程实体的概念

![进程的组成](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90.png)

操作系统在每个程序运行之前，都会为程序配置一个数据结构，称之为进程控制块（PCB），用来描述进程中的各种信息（比如程序代码存放位置、使用的IO设备、数据存放位置等），所以**程序段、数据段、PCB三个部分组成了进程实体（进程映像），程序段存放代码指令、数据段存放运行时产生和使用的数据、PCN存放管理进程的各种信息，一般情况下，我们简称进程实体为进程。PCB是进程中最重要的一部分，我们所谓创建进程，实质上就是创建进程实体中的PCB，而撤销进程，就是撤销进程实体中的PCB，而PCB就是进程存在的唯一标准**

![PCB](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/PCB.png)

进程从不同的角度可以有不同的定义：
- 进程程序的一次执行过程
- 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
- 进程是具有独立功能得到程序在数据集合上运行的过程，他是系统进行资源分配和调度的一个独立单位
- **进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位**

### 进程的管理

在操作系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来，而进程的组织分为两种方式：链接和索引

![进程的组织](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F.png)

链接组织：

![链接组织](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E9%93%BE%E6%8E%A5%E7%BB%84%E7%BB%87.png)

索引组织：

![索引组织](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87.png)

### 进程的特征

![进程的特征](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81.png)

## :palm_tree:进程的状态与转换

### 进程的状态

进程是程序的一次执行。在这个执行过程中，有的进程正在被CPU处理，有的又需要等待CPU服务，可见进程的状态是会有各种变化的，为了方便对各个进程进行管理，操作系统需要将进程合理地划分为几种状态

进程的五种状态：
- **创建态**：操作系统为该需要创建的进程分配所需的内存空间等资源，并为其创建、初始化PCB
- **运行态**：此时进程占有CPU，并且在CPU上运行，在单核处理机环境下，每一时刻最多只有一个进程处于运行态，在多核环境ixa可以同时有两个进程处于运行态
- **阻塞态**：此时进程因为等待某一时间而暂时不能运行，比如等待操作系统分配打印机、等待读磁盘操作的结果，CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将进程所需的资源分配到位才能得到CPU的服务
- **就绪态**：此时已经具有了除CPU以外所有运行条件，但是由于没有空闲CPU，所以暂时不能运行，进程已经拥有了除处理机以外的所有资源，一旦获得处理机，即可立刻进入运行态开始运行，用一句话总结即：**万事具备，只欠CPU**
- **终止态**：进程运行结束（或者因为bug导致进程无法继续执行下去，比如数组越界，空指针异常等），需要撤销进程，操作系统将分配给进程的资源回收，撤销PCB

### 进程的转换

既然我们为进程区别出了五种状态，那么我们就需要知道什么情况下进程会进行状态的转换呢？它又是怎么样转换呢？

![进程的转换](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png)

- 首先我们从进程的创建说起，当一个进程要被创建时，会创建、初始化PCB分配系统资源，进程此时位于创建态，当系统完成了创建进程的一系列工作之后，进程就进入了就绪态，此时会修改PCB相应的内容，并将进程放入就绪队列
- 当一个进程处于就绪态，就说明它已经拥有了除了处理机之外的所有资源，也就意味着它有机会被处理机调度，这时需要等待上个进程运行完毕，然后该进程获得CPU资源，此时进程修改PCB相应内容，进入运行态
- 此时进程有了所有要运行需要的资源，在于是得以运行，在运行过程中，如果进程运行的时间片到了，或者说处理机被优先级更高的进程抢占了，那么该进程会修改PCB相应内容并且回到就绪队列中，进入就绪态，等待再次被调度，但是如果进程在运行过程中需要申请某种系统资源，或者说要等待某个事件的发生，那么此时进程将会被阻塞，进程修改PCB相应内容进入阻塞态
- 当进程进入阻塞态之后，会等待申请的资源被分配，或者等待事件的发生，如果资源被分配或者事件发生，那么进程将会由阻塞态转入就绪态，修改PCB相应内容，并且进入到就绪队列之中
- 如果进程在运行态正常运行完毕，或者出现异常，那么将会进入终止态，进程撤销PCB，收回相应资源，被"杀死"

**注意：**
- 运行态-->阻塞态是一种进程自身做出的**主动行为**
- 阻塞态-->就绪态不是进程自身能够控制的，是一种**被动行为**
- 阻塞态是不能直接变为运行态的，也不能由就绪态直接转换为阻塞态（因为进入阻塞态时进程主动请求的，必然会在运行时才发出这种请求）

## :palm_tree:进程控制

我们知道了进程是有多种状态的，而且进程会在这些状态之间来回的转化的，那么操作系统是怎么控制进程在这些状态之间的转换的呢？这就是进程控制了。进程控制的主要功能时对系统中的所有进程实施有效的管理，它具有实现进程状态转换的功能

从进程状态转换中我们可以知道，如果进程要进行状态转换，都需要修改PCB中的内容，并且放到相应的对列中，那么此时有一种情况，我们将进程已经放入到相应的队列之中，但是我们还没来得及修改进程的PCB，这时PCB中的状态标志位和进程所处队列就不一致了，这样会导致系统错误，这种情况是非常危险的，为了解决这种情况，我们就使用**原语**来实现对进程的控制，**原语的特点就是执行期间不允许中断，只能一气呵成**

原语其实是采用关中断指令和开中断指令实现的

![原语](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%8E%9F%E8%AF%AD.png)

当原语相关的程序代码开始执行之前，会先执行一个关中断指令，在执行了这个指令之后，如果此时外部有一个中断信号传来，那么这个中断信号是会被忽略掉的，暂时不会被处理，这就保证了原语代码中的一系列处理不会被中断，只有在执行了开中断指令之后，接收到外部中断信号，才会转入到相应的中断处理程序，那么我们可以看到，通过关中断和开中断就可以实现原语这种保证了原子性的操作，保证了安全性

我们在以上过程中可以看到，关/开中断的权限非常大，必然是只允许在核心态下执行的特权指令

原语所做的其实就是三类事情：
1. 更新PCB中的一些信息（比如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）
  - 所有的进程控制原语一定都会修改进程状态标志
  - 剥夺当前运行进程的CPU使用权必然需要保存其运行环境
  - 某进程开始运行前必然要恢复其运行环境
2. 将PCB插入合适的队列
3. 分配/回收资源

## :palm_tree:进程通讯

我们都知道进程是操作系统分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立，而且为了保证系统安全，一个进程是不能直接访问另一个进程的地址空间的。

但是我们在平常使用软件的过程中，相互交换信息是必不可少的，比如我们在微信上从图库中选择一张照片发送给朋友，这里的微信进程获取了图片进程中的信息，所以为了保证这些进程之间信息交换的进行和进程间通讯的安全，操作系统就提供了一些方法来让进程之间能进行相互安全的通讯

操作系统提供三种通讯方式：

![进程通讯](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF.png)

### 共享存储

![共享存储](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8.png)

两个进程不能访问对方的地址空间，所以操作系统就给他们提供了共享空间，然后两个进程之间的通讯就可以通过共享空间来进行，**我们需要注意的是，两个进程对共享空间的访问是互斥的，当进程一写数据时，进程二是不能读数据的，反之也亦然。（而对共享空间的互斥访问是通过操作系统提供的同步互斥工具（如P、V操作）实现的）**

1. 基于数据结构的共享：比如共享空间中存放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级的通信方式
2. 基于存储区的共享：在内存中划出一块共享存储区，数据的形式、存放的位置等信息都是由进程协商决定，而不是操作系统，这种共享方式速度更快，是一种高级的通信方式

### 管道通信

"管道"是指用于连接读写进程的一个共享文件，又名pipe文件，其实就是在内存中开辟一个大小固定的缓冲区

![管道通信](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1.png)

**管道通信有以下几点需要注意**：
- 管道只能采取半双工通信，某一段时间内只能实现单向的传输，如果要实现双向同时通信，则需要设置两个管道
- 各进程需要互斥的访问管道
- 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走，当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞
- 如果没有写满，则不予许读，如果没读空，就不予许写
- 数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况

### 消息传递

进程间的数据交换以格式化的信息为单位，进程通过操作系统提供的"发送消息/接收消息"两个原语进行数据交换

![消息传递](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92.png)

消息传递分为两种方式：
1. 直接通讯方式：发送进程会通过发送原语发送给接收进程，然后这个消息就会被放到接收进程的消息缓冲队列的队尾，然后接收进程就会通过接收原语从队列中依次获取消息
2. 间接通讯方式：和直接通讯方式类似，只不过这些消息是先发送到中间实体（信箱）中，比如计网中的邮件系统

## :palm_tree:进程调度

当有一堆任务需要处理，但是由于资源有限，这些事情没法同时处理的时候，这就需要某种规则来决定处理这些任务的顺序，这就是调度所研究的问题

### 处理机调度的概念和层次

在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行

处理机调度有三个层次：
- 高级调度（作业调度）
- 中级调度（）
- 初级调度（）

#### 高级调度（作业调度）

由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序

高级调度（作业调度）就是按照一定的规则从外存上出狱后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它们获得竞争处理机的权利

**高级调度是外存和内存之间的调度**。每个作业之只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。由于作业结束后就直接撤销PCB就行了，**所以高级调度主要是指调入的问题**，因为只有调入的时机才需要操作系统来确定，但是调出的时机必然是作业运行结束才调出

#### 中级调度（内存调度）

引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存，**这么做的目的是为了提高内存利用率和系统吞吐量**

暂时调到外存等待的进程状态位挂起状态，值得注意的是，**PCB并不会一起调到外存，而是会常驻内存。**PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB保持对各个进程的监控、管理。被挂起的进程PCB会被放到挂起队列中

**中级调度（内存调度），就是决定将哪个出狱挂起状态的进程重新调入内存。**一个进程可能会被多次调出、调入内存，所以中级调度发生的频率比高级调度更高

#### 低级调度（进程调度）

低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它

进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度，进程调度的频率很高，一般几十毫秒一次

#### 三层调度的联系、对比

![三层调度](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E4%B8%89%E5%B1%82%E8%B0%83%E5%BA%A6.png)

### 进程调度的时机

进程调度，就是按照某种算法从就绪队列中选择一个进程为其分配处理机

那么什么时候需要进行进程的调度呢？

需要进行进程调度与切换的情况
- 当前运行的进程主动放弃处理机
  - 进程正常终止
  - 运行过程发生异常终止
  - 进程主动请求阻塞（比如等待I/O）
- 当前运行的进程被动放弃处理机
  - 分给进程的时间片用完
  - 有优先级更高的事需要处理（比如I/O中断）
  - 有更高优先级的进程进入就绪队列

![进程调度的时机](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%88%87%E6%8D%A2.png)

不能进行进程调度与切换情况：
- 在处理中断的过程中，中断处理过程复杂，与硬件息息相关，很难在中断的处理过程中进行进程的切换
- 进程在操作系统内核程序临界区中
- 在原子操作过程中（原语），原子操作不可中断，一气呵成

![进程不能调度的时机](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E8%BF%9B%E7%A8%8B%E4%B8%8D%E8%83%BD%E5%88%87%E6%8D%A2.png)

### 进程调度的切换

**进程调度**和**进程切换**的区别：

**狭义的进程调度**指的是从就绪队列中**选中一个要运行的进程**
**进程切换**是指**一个进程让出处理机，由另一个进程占用处理机的过程**
**广义的进程调度**则是**包含了狭义的进程调度和进程切换的过程**

进程切换的过程完成了：
- 对原来运行进程环境的保存
- 对新进程运行环境的恢复

我们需要注意的是：</br>
**进程切换是有代价的**，因此如果过于**频繁的进行进程的调度、切换**，必然会使**整个系统的效率降低**，使系统大部分时间花在了进程切换上，而真正用于执行进程的时间减少

### 进程调度的方式

两种方式：
- 非剥夺调度方式，又称为非抢占方式。只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态
  - 优点：实现简单，系统开销小
  - 缺点：无法及时处理紧急任务，适用于早期的批处理系统
- 剥夺调度方式，又称抢占式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的进程
  - 可以优先处理更紧急的进程，也可以实现让进程按时间片轮流执行的功能（通过时钟中断）。适用于分时操作系统、实时操作系统

### 进程调度算法

进程在进行调度的时候，我们需要按照一定的规则来，也就是进程调度的算法，而我们在观察一个进程调度算法的时候，主要看以下方面：
- 算法思想
- 算法规则
- 此算法用于 作业调度 还是 进程调度
- 算法是 抢占式 还是 非抢占式
- 算法的 优点 和 缺点
- 算法是否会导致饥饿

在下文的几种调度算法的介绍中，就是围绕着以上几个方面来讲述的

#### 调度算法的评价指标

调度算法的评价指标有以下几样：

- **CPU利用率**：指CPU工作的时间占中时间的比例
  1. 公式：**CPU利用率 = 工作的时间/总时间**
- **系统吞吐量**：但是时间内完成作业的数量
  1. 公式：**系统吞吐量= 总共完成了多少道作业/总共花了多少时间**
- **周转时间**：指作业被提交到系统开始，到作业完成为止的这段时间间隔 ，包括4个部分：作业在外存后备队列上等待作业调度的时间、进程在就绪队列上等待进程调度的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间
  1. 公式：**周转时间 = 作业完成时间 - 作业提交时间**
- **平均周转时间**：所有作业周转时间的平均值
  1. 公式：**平均周转时间 = 各作业周转时间之和/作业数**
- **带权周转时间**
  1. 公式：**带权周转时间 = 作业周转时间/作业实际运行的时间**
  2. 带权周转时间必然>=1
  3. 带权周转时间与周转时间都是越小越好
- **平均带权周转时间**
  1. 公式：**平均带权周转时间 = 各作业带权周转时间之和/作业数**
- **等待时间**：指进程/作业处于等待处理机状态时间之和
  1. 对于进程，等待IO完成期间其实进程也是在被服务，所以不计入等待时间
  2. 对于作业，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间
- **响应时间**：指从用户提交请求到首次产生响应所用的时间

#### FCFS（先到先进行）算法

- 算法思想：主要从公平的角度考虑，先到来的进程先被调度，后来的进程后被调度，按先来后到的顺序调度（类似生活中排队买东西的例子）
- 算法规则：**按照作业/进程到达的先后顺序进行服务**
- 用于作业/进程：用于作业调度的额时候，考虑的是哪个作业先到达后备队列；用于进程调度的时候，考虑的是哪个进程先到达就绪队列
- 是否可抢占：**非抢占式**的算法
- 优点：**公平，算法实现简单**
- 缺点：排在长作业后面的短作业需要等待很长时间，带权周转时间很长，对短作业来说用户的体验十分不好，**即FCFS算法对长作业有力，对短作业不利**
- 是否会导致饥饿：不会，只要前面的进程能执行完 ，就一定能执行到本进程，所以不会导致饥饿

!1[FCFS](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/FCFS.png)

#### SJF（短作业优先）算法

- 算法思想：**追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间**
- 算法规则：**最短的作业/进程**可以**优先得到服务**（所谓最短，即是服务时间最短）
- 用于作业/进程：既可用于作业调度，也可以用于进程调度，用于进程调度时称为“短进程优先算法”
- 是否可抢占：非抢占式算法，但是也有抢占式的版本——最短剩余时间优先算法
- 优点：最短的平均等待时间、平均周转时间
- 缺点：不公平，对短作业有利、对长作业不利。可能会有饥饿现象的产生，还有另外很重要的一点，运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先
- 是否会导致饥饿：可能会，当一个进程的需要运行的时间很长，而且有源源不断的短进程进入时，长进程会饥饿

![SJF](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/SJF.png)

#### HRRN（高响应比优先）算法

在上面的两种算法当中：
- FCFS算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务，但是没有考虑到作业的运行时间，因此**导致了对短作业不友好的问题**
- SJF算法是选择一个执行时间最短的作业为其服务，但是又完全不考虑各个作业的等待时间，因此**导致了对长作业不友好的问题，甚至还会造成饥饿问题**

为了中和一下上面两种算法所带来的问题，人们设计出了HRRN算法，在考虑到各个作业的等待时间的同时，也能兼顾运行时间

- 算法思想：**综合考虑作业/进程的等待时间和要求服务的时间**
- 算法规则：在每次调度时**先计算各个作业/进程的响应比**，选择响应比最高的作业/进程先为其服务，**响应比 = （等待时间+服务时间）/服务时间**
- 用于作业/进程：既可用于作业调度，也可以用于进程调度
- 是否可抢占：**非抢占式算法**，因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比
- 优点：综合考虑了等待时间和运行时间，**在等待时间相同时，让需要服务时间短的进程优先（FCFS的优点）；在需要服务时间相同时，让等待时间长的优先（SJF的优点）**
- 是否会导致饥饿：不会，对长作业来说，等待时间越长，其响应比也就越大，避免了长作业饥饿的问题

![HRRN](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/HRRN.png)

#### 三种算法的对比总结

以上的三种算法主要关心的是：**用户的公平性、平均周转时间、平均等待时间等**评价**系统整体性能的指标**，但是并**不关心“响应时间”**，也**不区分任务的紧急程度**，因此对于用户来说，**交互性能很糟糕**，因此这三种算法一般用于**早期的批处理系统**，而适用于交互式系统的调度算法，将是以下我们将介绍的三种算法

![三种算法比较总结](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E4%B8%89%E7%A7%8D%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.png)

#### 时间片轮转算法

- 算法思想：
- 算法规则：
- 用于作业/进程：
- 是否可抢占：
- 优点：
- 缺点：
- 是否会导致饥饿

![]()

#### 优先级调度算法

- 算法思想：
- 算法规则：
- 用于作业/进程：
- 是否可抢占：
- 优点：
- 缺点：
- 是否会导致饥饿

![]()

#### 多级反馈队列算法

- 算法思想：
- 算法规则：
- 用于作业/进程：
- 是否可抢占：
- 优点：
- 缺点：
- 是否会导致饥饿

![]()



## :palm_tree:进程同步的与互斥

### 信号量机制

### 进程同步

### 进程互斥
