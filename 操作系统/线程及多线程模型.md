# 线程

## 什么是线程，为什么要引入线程

在我们没有引入进程之前，程序之间只能串行的执行，我们是不能一边聊QQ一边听音乐的，在我们引入进程之后，操作系统是可以并发的执行的进程的，于是我们可以完成边聊QQ边听音乐的目标，但是随着程序的发展，一个进程是可以做多样事情的，比如说QQ，既可以聊天，又可以发文件，又可以视频语音，而进程是一次程序的顺序执行，这些功能我们在使用的时候显然是没有固定先后顺序的，在我们用户看来它们是可以同时发生的。显然单靠进程是没有办法解决这个问题的，所以我们引入了线程

![线程](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%BA%BF%E7%A8%8B.png)

**在我们引入了线程之后，CPU的调度对象就不在是进程了，而是线程，传统的进程是程序执行流的最小的单位，而现在最小的程序执行流单位是线程。所以所谓的线程，我们可以理解为轻量级的进程，线程是一个基本的CPU执行单元，也是程序执行流的最小单位。在引入线程之后，进程只是作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）**

## 引入线程之后，有什么变化

![引入线程的变化](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%BC%95%E5%85%A5%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%90%8E%E7%9A%84%E5%8F%98%E5%8C%96.png)

- 从**资源分配、调度**上来讲：
  - 在传统进程机制中，进程是资源分配和调度的基本单位
  - 在引入线程后，进程是资源分配的基本单位，线程是系统调度的基本单位
- 从**并发性**上来讲：
  - 传统进程机制中，只能在进程间并发
  - 引入线程之后，各线程间也可以并发，提高了并发度
- 从**系统开销**上讲：
  - 进程间的并发，需要切换进程的运行环境，系统开销很大
  - 线程间的并发，如果是在同一进程内，不需要切换进程环境，系统开销小

## 线程的属性

![线程属性](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7.png)

- 线程是处理机调度的基本单位，进程是处理机分配系统资源的基本单位
- 多CPU计算机中，各个线程可占用不同的CPU
- 每个线程都类似于进程有一个线程ID、线程控制块(PCB)
- 线程也有就绪、阻塞、运行三种基本状态
- 线程几乎不拥有系统资源，系统资源都是分配到进程上的
- 同一进程的所有线程共享该进程的所有资源
- 由于同一进程的线程之间是共享内存地址空间，同一进程中的线程通信是无需操作系统干预的
- 同一进程中的线程切换，不会引起进程切换
- 不同进程中的线程切换，会引起进程切换
- 切换同进程中的线程，系统开销很小；切换进程，系统开销较大

## 线程的实现方式

线程的实现方式分为两种：用户级线程和内核级线程

在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m个内核级线程上（n>=m）

![线程的实现方式](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.png)

**重点：由于操作系统只看得见内核级线程，因此只有内核级线程才是处理机分配的单位**

### 用户级线程

![用户级线程](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B.png)

- 用户级线程是**应用程序用过线程库实现**，所有的线程管理工作都由应用程序负责（包括同进程内线程切换）
- 用户级线程，由于是应用程序通过线程库实现的，不需要借助到操作系统，所以**在用户态下即可完成**，并不需要操作系统的干预
- 用户级线程，在用户看来是有多个线程的，但是在操作系统的内核看来，并不能意识到多个线程的存在，在操作系统看来就是一个进程，所以**操作系统还是以进程为调度单位**，也可以说是**用户级线程对用户不透明，对操作系统透明**
- 用户级线程可以理解为：**用户能够看到的线程**

### 内核级线程

![内核级线程](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B.png)

- 内核级线程的管理工作是由**操作系统内核完成的**
- 线程调度、切换工作都是由内核负责，因此内核级线程的切换必然需要**在核心态下才能完成**
- 内核级线程可以理解为：**从操作系统内核视角看能看到的线程**
- 如上图所示，对用户来说看到的是三个线程，对操作系统来说，看到的也是三个线程
- **此时操作系统的调度单位是内核级线程**

## 多线程模型

在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”的问题

多线程模型分为三类：
- 一对一
- 一对多
-- 多对多

### 一对一模型

![一对一](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E4%B8%80%E5%AF%B9%E4%B8%80.png)

一对一模型：一个用户级线程映射到一个内核级线程同数量的内核级线程
- 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强，多线程可在多核处理机上并行执行
- 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大

### 多对一模型

![多对一](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%A4%9A%E5%AF%B9%E4%B8%80.png)

多对一模型：多个用户级线程映射到一个内核级线程，每个用户进程只对应一个内核级线程
- 优点：用户级线程的切换在用户态下即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
- 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程不可以在多核处理机上并行运行

### 多对多模型

![多对多](https://github.com/Lany-Java/JavaStudy/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/img/%E5%A4%9A%E5%AF%B9%E5%A4%9A.png)

多对多模型：n个用户级线程映射到m个内核级线程同数量的内核级线程，每个用户进程对应m个内核级线程
- 克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点
